{"version":3,"sources":["../../../src/billing/services/wayforpay.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, InternalServerErrorException, Logger, Inject, forwardRef } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport axios from 'axios';\nimport * as crypto from 'crypto';\nimport { Subscription } from '../../database/entities/Subscription.entity';\nimport { Organization } from '../../database/entities/Organization.entity';\nimport {\n    SubscriptionStatus,\n    SubscriptionPlan,\n    SubscriptionProvider,\n} from '../../database/entities/enums/subscription.enum';\nimport { CreateCheckoutSessionDto } from '../dto/billing.dto';\nimport { AuditService } from '../../auth/services/audit.service';\nimport { BillingService } from './billing.service';\n\ninterface WayForPayCheckoutResponse {\n    url: string;\n    transactionId: string;\n}\n\ninterface WayForPayWebhookPayload {\n    merchantAccount: string;\n    merchantDomainName: string;\n    orderReference: string;\n    orderDate: number;\n    amount: number;\n    currency: string;\n    productCount: number;\n    productName: string[];\n    productPrice: number[];\n    productPriceUsd: number[];\n    orderStatus: string;\n    signature: string;\n    card?: string;\n    cardType?: string;\n    clientName?: string;\n    clientEmail?: string;\n    clientPhone?: string;\n    reason?: string;\n    reasonCode?: number;\n}\n\ninterface PendingOrder {\n    tenantId: string;\n    plan: SubscriptionPlan;\n    createdAt: Date;\n    email?: string;\n}\n\n/**\n * WayForPay Service\n * Ukrainian payment processor integration\n */\n@Injectable()\nexport class WayForPayService {\n    private readonly logger = new Logger(WayForPayService.name);\n    private readonly merchantAccount: string;\n    private readonly merchantDomain: string;\n    private readonly merchantSecretKey: string;\n    private readonly apiUrl: string;\n    private readonly returnUrl: string;\n    private readonly serviceUrl: string;\n\n    // In-memory cache for pending orders (in production, use Redis)\n    private pendingOrders: Map<string, PendingOrder> = new Map();\n\n    constructor(\n        private readonly configService: ConfigService,\n        private readonly auditService: AuditService,\n        @Inject(forwardRef(() => BillingService))\n        private readonly billingService: BillingService,\n        @InjectRepository(Subscription)\n        private readonly subscriptionRepository: Repository<Subscription>,\n        @InjectRepository(Organization)\n        private readonly organizationRepository: Repository<Organization>,\n    ) {\n        this.merchantAccount = this.configService.get<string>('WAYFORPAY_MERCHANT_ACCOUNT')!;\n        this.merchantDomain = this.configService.get<string>('WAYFORPAY_MERCHANT_DOMAIN')!;\n        this.merchantSecretKey = this.configService.get<string>('WAYFORPAY_MERCHANT_SECRET_KEY')!;\n        this.apiUrl = this.configService.get<string>('WAYFORPAY_API_URL', 'https://secure.wayforpay.com/pay');\n        this.returnUrl = this.configService.get<string>('APP_URL', 'https://laworganizer.ua');\n        this.serviceUrl = this.configService.get<string>('APP_URL', 'https://laworganizer.ua');\n\n        if (!this.merchantAccount || !this.merchantSecretKey) {\n            this.logger.warn('WayForPay is not configured - payment functionality will be limited');\n        }\n    }\n\n    /**\n     * Create checkout session for subscription\n     */\n    async createCheckoutSession(\n        tenantId: string,\n        dto: CreateCheckoutSessionDto,\n    ): Promise<{ checkoutUrl: string; sessionId: string }> {\n        if (!this.merchantAccount || !this.merchantSecretKey) {\n            throw new InternalServerErrorException('WayForPay is not configured');\n        }\n\n        const orderReference = this.generateOrderReference(tenantId, dto.plan);\n        const planDetails = this.getPlanDetails(dto.plan);\n        const amount = planDetails.amount;\n\n        // Store pending order for webhook processing\n        this.pendingOrders.set(orderReference, {\n            tenantId,\n            plan: dto.plan,\n            createdAt: new Date(),\n            email: dto.successUrl ? this.extractEmailFromUrl(dto.successUrl) : undefined,\n        });\n\n        const orderDate = Math.floor(Date.now() / 1000);\n\n        // Generate signature according to WayForPay documentation\n        const signatureString = [\n            this.merchantAccount,\n            this.merchantDomain,\n            orderReference,\n            orderDate.toString(),\n            amount.toString(),\n            'UAH',\n            planDetails.name,\n            '1',\n            amount.toString(),\n        ].join(';');\n\n        const merchantSignature = this.generateWayForPaySignature(signatureString);\n\n        // Build request data\n        const requestData = {\n            merchantAccount: this.merchantAccount,\n            merchantDomainName: this.merchantDomain,\n            merchantSignature,\n            orderReference,\n            orderDate,\n            amount,\n            currency: 'UAH',\n            productName: [planDetails.name],\n            productCount: [1],\n            productPrice: [amount],\n            language: 'UA',\n            serviceUrl: `${this.serviceUrl}/api/billing/webhooks/wayforpay`,\n            returnURL: dto.successUrl || `${this.returnUrl}/billing/success?session_id=${orderReference}`,\n            cancelURL: dto.cancelUrl || `${this.returnUrl}/billing/cancel?session_id=${orderReference}`,\n            defaultPaymentSystem: 'card',\n        };\n\n        try {\n            this.logger.log(`Creating WayForPay checkout session for tenant ${tenantId}, plan ${dto.plan}`);\n\n            // WayForPay uses form submission, so we construct the payment URL\n            const checkoutUrl = this.buildPaymentUrl(requestData);\n\n            // Log audit\n            await this.auditService.log({\n                tenantId,\n                action: 'create',\n                entityType: 'CheckoutSession',\n                entityId: orderReference,\n                metadata: {\n                    plan: dto.plan,\n                    provider: 'wayforpay',\n                    amount,\n                    currency: 'UAH',\n                },\n            });\n\n            this.logger.log(`WayForPay checkout session created: ${orderReference}`);\n\n            return {\n                checkoutUrl,\n                sessionId: orderReference,\n            };\n        } catch (error) {\n            this.logger.error('Failed to create WayForPay checkout session', error);\n            throw new InternalServerErrorException('Failed to create checkout session');\n        }\n    }\n\n    /**\n     * Handle webhook callback from WayForPay\n     */\n    async handleWebhook(payload: WayForPayWebhookPayload): Promise<{ status: string }> {\n        this.logger.log(`Received WayForPay webhook for order ${payload.orderReference}`);\n\n        // Verify signature\n        if (!this.verifyWebhookSignature(payload)) {\n            this.logger.error('Invalid webhook signature');\n            throw new BadRequestException('Invalid signature');\n        }\n\n        // Extract tenant ID and plan from order reference\n        const orderInfo = this.parseOrderReference(payload.orderReference);\n\n        // Try to get from cache first\n        let pendingOrder = this.pendingOrders.get(payload.orderReference);\n\n        // If not in cache, try to find subscription by order reference\n        if (!pendingOrder) {\n            const existingSubscription = await this.subscriptionRepository.findOne({\n                where: { externalId: payload.orderReference },\n            });\n\n            if (existingSubscription) {\n                pendingOrder = {\n                    tenantId: existingSubscription.tenantId,\n                    plan: existingSubscription.plan,\n                    createdAt: existingSubscription.createdAt,\n                };\n            } else {\n                // Fallback to parsed order reference\n                pendingOrder = {\n                    tenantId: orderInfo.tenantId,\n                    plan: orderInfo.plan,\n                    createdAt: new Date(),\n                };\n            }\n        }\n\n        const { tenantId, plan } = pendingOrder;\n\n        // Map WayForPay status to our enum\n        const statusMap: Record<string, SubscriptionStatus> = {\n            'Approved': SubscriptionStatus.ACTIVE,\n            'Awaiting Confirmation': SubscriptionStatus.TRIALING,\n            'In Progress': SubscriptionStatus.TRIALING,\n            'Canceled': SubscriptionStatus.CANCELED,\n            'Declined': SubscriptionStatus.PAST_DUE,\n            'Expired': SubscriptionStatus.CANCELED,\n            'Refunded': SubscriptionStatus.CANCELED,\n            'Partial Refunded': SubscriptionStatus.ACTIVE,\n            'Processing': SubscriptionStatus.TRIALING,\n            'Waiting Auth Complete': SubscriptionStatus.TRIALING,\n        };\n\n        const status = statusMap[payload.orderStatus];\n\n        if (!status) {\n            this.logger.warn(`Unhandled WayForPay order status: ${payload.orderStatus}`);\n            return { status: 'ignored' };\n        }\n\n        try {\n            // Check if subscription exists\n            let subscription = await this.subscriptionRepository.findOne({\n                where: { tenantId },\n            });\n\n            const currentPeriodEndAt = new Date();\n            currentPeriodEndAt.setMonth(currentPeriodEndAt.getMonth() + 1);\n\n            if (subscription) {\n                // Update existing subscription\n                subscription.status = status;\n                subscription.plan = plan;\n                subscription.externalId = payload.orderReference;\n                subscription.lastSyncedAt = new Date();\n                subscription.amountCents = Math.round(payload.amount * 100);\n                subscription.currency = payload.currency;\n\n                if (status === SubscriptionStatus.ACTIVE) {\n                    subscription.currentPeriodStartAt = new Date();\n                    subscription.currentPeriodEndAt = currentPeriodEndAt;\n                    subscription.canceledAt = null;\n                    subscription.cancelAtPeriodEnd = false;\n                } else if (status === SubscriptionStatus.CANCELED) {\n                    subscription.canceledAt = new Date();\n                }\n\n                subscription.latestWebhookEventId = payload.orderReference;\n                subscription.metadata = {\n                    ...subscription.metadata,\n                    wayforpay: {\n                        card: payload.card,\n                        cardType: payload.cardType,\n                        clientName: payload.clientName,\n                        clientEmail: payload.clientEmail,\n                        lastWebhookAt: new Date().toISOString(),\n                        orderStatus: payload.orderStatus,\n                        reason: payload.reason,\n                        reasonCode: payload.reasonCode,\n                    },\n                };\n\n                await this.subscriptionRepository.save(subscription);\n                this.logger.log(`Updated subscription ${subscription.id} for tenant ${tenantId}`);\n            } else {\n                // Create new subscription\n                subscription = this.subscriptionRepository.create({\n                    tenantId,\n                    provider: SubscriptionProvider.WAYFORPAY,\n                    externalId: payload.orderReference,\n                    subscriptionExternalId: payload.orderReference,\n                    plan,\n                    status,\n                    amountCents: Math.round(payload.amount * 100),\n                    currency: payload.currency,\n                    currentPeriodStartAt: status === SubscriptionStatus.ACTIVE ? new Date() : undefined,\n                    currentPeriodEndAt: status === SubscriptionStatus.ACTIVE ? currentPeriodEndAt : undefined,\n                    lastSyncedAt: new Date(),\n                    latestWebhookEventId: payload.orderReference,\n                    metadata: {\n                        wayforpay: {\n                            card: payload.card,\n                            cardType: payload.cardType,\n                            clientName: payload.clientName,\n                            clientEmail: payload.clientEmail,\n                            lastWebhookAt: new Date().toISOString(),\n                            orderStatus: payload.orderStatus,\n                            reason: payload.reason,\n                            reasonCode: payload.reasonCode,\n                        },\n                    },\n                });\n\n                await this.subscriptionRepository.save(subscription);\n                this.logger.log(`Created subscription ${subscription.id} for tenant ${tenantId}`);\n            }\n\n            // Update organization subscription fields\n            await this.organizationRepository.update(\n                { id: tenantId },\n                {\n                    subscriptionPlan: plan,\n                    subscriptionStatus: status,\n                    currentPeriodEndAt: status === SubscriptionStatus.ACTIVE ? currentPeriodEndAt : undefined,\n                },\n            );\n\n            // Log audit\n            await this.auditService.log({\n                tenantId,\n                action: 'update',\n                entityType: 'Subscription',\n                entityId: subscription.id,\n                metadata: {\n                    provider: 'wayforpay',\n                    status,\n                    plan,\n                    orderReference: payload.orderReference,\n                    orderStatus: payload.orderStatus,\n                    amount: payload.amount,\n                    currency: payload.currency,\n                },\n            });\n\n            // Clean up pending order\n            this.pendingOrders.delete(payload.orderReference);\n\n            this.logger.log(`WayForPay webhook processed successfully for order ${payload.orderReference}`);\n\n            return { status: 'ok' };\n        } catch (error) {\n            this.logger.error(`Failed to process webhook for order ${payload.orderReference}`, error);\n            throw new InternalServerErrorException('Failed to process webhook');\n        }\n    }\n\n    /**\n     * Verify WayForPay webhook signature\n     */\n    verifyWebhookSignature(payload: WayForPayWebhookPayload): boolean {\n        if (!this.merchantSecretKey) {\n            return false;\n        }\n\n        try {\n            // Build signature string according to WayForPay documentation\n            const signatureFields = [\n                payload.merchantAccount,\n                payload.merchantDomainName,\n                payload.orderReference,\n                payload.orderDate.toString(),\n                payload.amount.toString(),\n                payload.currency,\n                payload.productCount.toString(),\n            ];\n\n            // Add product names\n            payload.productName.forEach(name => signatureFields.push(name));\n\n            // Add product prices\n            payload.productPrice.forEach(price => signatureFields.push(price.toString()));\n\n            // Add USD prices if available\n            if (payload.productPriceUsd && payload.productPriceUsd.length > 0) {\n                payload.productPriceUsd.forEach(price => signatureFields.push(price.toString()));\n            }\n\n            const signatureString = signatureFields.join(';');\n            const expectedSignature = this.generateWayForPaySignature(signatureString);\n\n            return crypto.timingSafeEqual(\n                Buffer.from(payload.signature, 'hex'),\n                Buffer.from(expectedSignature, 'hex'),\n            );\n        } catch (error) {\n            this.logger.error('Error verifying webhook signature', error);\n            return false;\n        }\n    }\n\n    /**\n     * Generate response signature for WayForPay callback\n     */\n    generateCallbackResponse(orderReference: string, status: 'accept' | 'decline'): string {\n        const signatureString = orderReference + ';' + status + ';' + this.merchantSecretKey;\n        return this.generateWayForPaySignature(signatureString);\n    }\n\n    /**\n     * Get subscription status by order reference\n     */\n    async getPaymentStatus(orderReference: string): Promise<{\n        status: SubscriptionStatus | null;\n        plan: SubscriptionPlan | null;\n        amount: number | null;\n    }> {\n        const subscription = await this.subscriptionRepository.findOne({\n            where: { externalId: orderReference },\n        });\n\n        if (!subscription) {\n            return { status: null, plan: null, amount: null };\n        }\n\n        return {\n            status: subscription.status,\n            plan: subscription.plan,\n            amount: subscription.amountCents ? subscription.amountCents / 100 : null,\n        };\n    }\n\n    /**\n     * Generate order reference with encoded tenant and plan\n     */\n    private generateOrderReference(tenantId: string, plan: SubscriptionPlan): string {\n        const timestamp = Date.now();\n        const random = crypto.randomBytes(4).toString('hex');\n        // Format: WFP-{tenantPrefix}-{plan}-{timestamp}-{random}\n        return `WFP-${tenantId.substring(0, 8)}-${plan}-${timestamp}-${random}`;\n    }\n\n    /**\n     * Parse order reference to extract tenant ID and plan\n     */\n    private parseOrderReference(reference: string): { tenantId: string; plan: SubscriptionPlan } {\n        const parts = reference.split('-');\n\n        // Format: WFP-{tenantPrefix}-{plan}-{timestamp}-{random}\n        if (parts.length >= 4 && parts[0] === 'WFP') {\n            const tenantPrefix = parts[1];\n            const planStr = parts[2] as SubscriptionPlan;\n\n            // Try to find subscription by order reference\n            return {\n                tenantId: tenantPrefix, // Will be resolved from pending orders or existing subscription\n                plan: Object.values(SubscriptionPlan).includes(planStr) ? planStr : SubscriptionPlan.BASIC,\n            };\n        }\n\n        // Legacy format fallback\n        return {\n            tenantId: parts[0],\n            plan: (parts[1] as SubscriptionPlan) || SubscriptionPlan.BASIC,\n        };\n    }\n\n    /**\n     * Generate WayForPay signature (HMAC-MD5)\n     */\n    private generateWayForPaySignature(data: string): string {\n        return crypto\n            .createHmac('md5', this.merchantSecretKey)\n            .update(data)\n            .digest('hex');\n    }\n\n    /**\n     * Build payment URL for redirect\n     */\n    private buildPaymentUrl(requestData: any): string {\n        const params = new URLSearchParams();\n\n        Object.entries(requestData).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    params.append(`${key}[${index}]`, String(item));\n                });\n            } else {\n                params.append(key, String(value));\n            }\n        });\n\n        return `${this.apiUrl}?${params.toString()}`;\n    }\n\n    /**\n     * Get plan details for WayForPay\n     */\n    private getPlanDetails(plan: SubscriptionPlan): { name: string; amount: number } {\n        const plans: Record<SubscriptionPlan, { name: string; amount: number }> = {\n            [SubscriptionPlan.BASIC]: {\n                name: 'Law Organizer Basic',\n                amount: 0,\n            },\n            [SubscriptionPlan.PROFESSIONAL]: {\n                name: 'Law Organizer Professional',\n                amount: 499, // UAH per month\n            },\n            [SubscriptionPlan.ENTERPRISE]: {\n                name: 'Law Organizer Enterprise',\n                amount: 1499, // UAH per month\n            },\n        };\n\n        return plans[plan];\n    }\n\n    /**\n     * Extract email from URL query params\n     */\n    private extractEmailFromUrl(url: string): string {\n        try {\n            const urlObj = new URL(url);\n            return urlObj.searchParams.get('email') || '';\n        } catch {\n            return '';\n        }\n    }\n\n    /**\n     * Clean up expired pending orders (call periodically)\n     */\n    cleanupExpiredOrders(): void {\n        const now = Date.now();\n        const expirationTime = 24 * 60 * 60 * 1000; // 24 hours\n\n        for (const [orderRef, order] of this.pendingOrders.entries()) {\n            if (now - order.createdAt.getTime() > expirationTime) {\n                this.pendingOrders.delete(orderRef);\n                this.logger.log(`Cleaned up expired pending order: ${orderRef}`);\n            }\n        }\n    }\n}\n"],"names":["WayForPayService","createCheckoutSession","tenantId","dto","merchantAccount","merchantSecretKey","InternalServerErrorException","orderReference","generateOrderReference","plan","planDetails","getPlanDetails","amount","pendingOrders","set","createdAt","Date","email","successUrl","extractEmailFromUrl","undefined","orderDate","Math","floor","now","signatureString","merchantDomain","toString","name","join","merchantSignature","generateWayForPaySignature","requestData","merchantDomainName","currency","productName","productCount","productPrice","language","serviceUrl","returnURL","returnUrl","cancelURL","cancelUrl","defaultPaymentSystem","logger","log","checkoutUrl","buildPaymentUrl","auditService","action","entityType","entityId","metadata","provider","sessionId","error","handleWebhook","payload","verifyWebhookSignature","BadRequestException","orderInfo","parseOrderReference","pendingOrder","get","existingSubscription","subscriptionRepository","findOne","where","externalId","statusMap","SubscriptionStatus","ACTIVE","TRIALING","CANCELED","PAST_DUE","status","orderStatus","warn","subscription","currentPeriodEndAt","setMonth","getMonth","lastSyncedAt","amountCents","round","currentPeriodStartAt","canceledAt","cancelAtPeriodEnd","latestWebhookEventId","wayforpay","card","cardType","clientName","clientEmail","lastWebhookAt","toISOString","reason","reasonCode","save","id","create","SubscriptionProvider","WAYFORPAY","subscriptionExternalId","organizationRepository","update","subscriptionPlan","subscriptionStatus","delete","signatureFields","forEach","push","price","productPriceUsd","length","expectedSignature","crypto","timingSafeEqual","Buffer","from","signature","generateCallbackResponse","getPaymentStatus","timestamp","random","randomBytes","substring","reference","parts","split","tenantPrefix","planStr","Object","values","SubscriptionPlan","includes","BASIC","data","createHmac","digest","params","URLSearchParams","entries","key","value","Array","isArray","item","index","append","String","apiUrl","plans","PROFESSIONAL","ENTERPRISE","url","urlObj","URL","searchParams","cleanupExpiredOrders","expirationTime","orderRef","order","getTime","configService","billingService","Logger","Map","BillingService"],"mappings":"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"}