{"version":3,"sources":["../../../src/billing/services/stripe.service.ts"],"sourcesContent":["import { Injectable, BadRequestException, InternalServerErrorException } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport Stripe from 'stripe';\nimport { Subscription } from '../../database/entities/Subscription.entity';\nimport { SubscriptionStatus, SubscriptionPlan } from '../../database/entities/enums/subscription.enum';\nimport { CreateCheckoutSessionDto } from '../dto/billing.dto';\nimport { AuditService } from '../../auth/services/audit.service';\n\n/**\n * Stripe Service\n */\n@Injectable()\nexport class StripeService {\n    private stripe: Stripe;\n\n    constructor(\n        private readonly configService: ConfigService,\n        private readonly auditService: AuditService,\n    ) {\n        const secretKey = this.configService.get<string>('STRIPE_SECRET_KEY');\n\n        if (!secretKey) {\n            throw new Error('STRIPE_SECRET_KEY is not configured');\n        }\n\n        this.stripe = new Stripe(secretKey, {\n            apiVersion: '2023-08-16',\n        });\n    }\n\n    /**\n     * Create checkout session\n     */\n    async createCheckoutSession(\n        tenantId: string,\n        dto: CreateCheckoutSessionDto,\n    ): Promise<{ checkoutUrl: string; sessionId: string }> {\n        const prices = this.getPlanPrices(dto.plan);\n\n        // Check if customer exists\n        let customerId = await this.getCustomerId(tenantId);\n\n        if (!customerId) {\n            // Create customer\n            const customer = await this.stripe.customers.create({\n                metadata: { tenantId },\n            });\n\n            customerId = customer.id;\n        }\n\n        // Create checkout session\n        const session = await this.stripe.checkout.sessions.create({\n            customer: customerId,\n            payment_method_types: ['card'],\n            line_items: prices.map(price => ({\n                price: price.id,\n                quantity: 1,\n            })),\n            mode: 'subscription',\n            success_url: dto.successUrl || `${this.configService.get('APP_URL')}/billing/success?session_id={CHECKOUT_SESSION_ID}`,\n            cancel_url: dto.cancelUrl || `${this.configService.get('APP_URL')}/billing/cancel`,\n            subscription_data: {\n                trial_period_days: dto.trial ? 14 : undefined,\n                metadata: { tenantId, plan: dto.plan },\n            },\n            allow_promotion_codes: true,\n        });\n\n        // Log audit\n        await this.auditService.log({\n            tenantId,\n            action: 'create',\n            entityType: 'CheckoutSession',\n            entityId: session.id,\n            metadata: {\n                plan: dto.plan,\n                trial: dto.trial,\n            },\n        });\n\n        return {\n            checkoutUrl: session.url!,\n            sessionId: session.id,\n        };\n    }\n\n    /**\n     * Create customer portal session\n     */\n    async createPortalSession(\n        tenantId: string,\n        returnUrl: string,\n    ): Promise<{ url: string }> {\n        const customerId = await this.getCustomerId(tenantId);\n\n        if (!customerId) {\n            throw new BadRequestException('Customer not found');\n        }\n\n        const session = await this.stripe.billingPortal.sessions.create({\n            customer: customerId,\n            return_url: returnUrl,\n        });\n\n        return { url: session.url! };\n    }\n\n    /**\n     * Cancel subscription\n     */\n    async cancelSubscription(\n        subscriptionId: string,\n        atPeriodEnd: boolean = true,\n    ): Promise<Stripe.Subscription> {\n        return this.stripe.subscriptions.update(subscriptionId, {\n            cancel_at_period_end: atPeriodEnd,\n        });\n    }\n\n    /**\n     * Resume subscription\n     */\n    async resumeSubscription(subscriptionId: string): Promise<Stripe.Subscription> {\n        return this.stripe.subscriptions.update(subscriptionId, {\n            cancel_at_period_end: false,\n        });\n    }\n\n    /**\n     * Upgrade/Downgrade plan\n     */\n    async updateSubscriptionPlan(\n        subscriptionId: string,\n        plan: SubscriptionPlan,\n    ): Promise<Stripe.Subscription> {\n        const price = this.getPlanPrice(plan);\n\n        return this.stripe.subscriptions.update(subscriptionId, {\n            items: [{\n                id: (await this.stripe.subscriptions.retrieve(subscriptionId)).items.data[0].id,\n                price: price.id,\n            }],\n            proration_behavior: 'create_prorations',\n        });\n    }\n\n    /**\n     * Handle webhook event\n     */\n    async handleWebhook(payload: string, signature: string): Promise<void> {\n        const webhookSecret = this.configService.get<string>('STRIPE_WEBHOOK_SECRET');\n\n        if (!webhookSecret) {\n            throw new Error('STRIPE_WEBHOOK_SECRET is not configured');\n        }\n\n        let event: Stripe.Event;\n\n        try {\n            event = this.stripe.webhooks.constructEvent(\n                payload,\n                signature,\n                webhookSecret\n            );\n        } catch (error) {\n            throw new BadRequestException('Invalid webhook signature');\n        }\n\n        // Handle different event types\n        switch (event.type) {\n            case 'checkout.session.completed':\n                await this.handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);\n                break;\n\n            case 'customer.subscription.created':\n                await this.handleSubscriptionCreated(event.data.object as Stripe.Subscription);\n                break;\n\n            case 'customer.subscription.updated':\n                await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);\n                break;\n\n            case 'customer.subscription.deleted':\n                await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);\n                break;\n\n            case 'invoice.paid':\n                await this.handleInvoicePaid(event.data.object as Stripe.Invoice);\n                break;\n\n            case 'invoice.payment_failed':\n                await this.handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);\n                break;\n\n            default:\n                console.log(`Unhandled event type: ${event.type}`);\n        }\n    }\n\n    /**\n     * Handle checkout session completed\n     */\n    private async handleCheckoutSessionCompleted(session: Stripe.Checkout.Session): Promise<void> {\n        const tenantId = session.metadata?.tenantId;\n        const plan = session.metadata?.plan as SubscriptionPlan;\n\n        if (!tenantId || !plan) {\n            throw new InternalServerErrorException('Missing metadata');\n        }\n\n        // TODO: Update subscription in database\n        console.log('Checkout session completed', { tenantId, plan });\n    }\n\n    /**\n     * Handle subscription created\n     */\n    private async handleSubscriptionCreated(subscription: Stripe.Subscription): Promise<void> {\n        const tenantId = subscription.metadata?.tenantId;\n        const plan = subscription.metadata?.plan as SubscriptionPlan;\n\n        if (!tenantId) {\n            throw new InternalServerErrorException('Missing tenant_id in metadata');\n        }\n\n        // TODO: Create/update subscription in database\n        console.log('Subscription created', { tenantId, plan, subscriptionId: subscription.id });\n    }\n\n    /**\n     * Handle subscription updated\n     */\n    private async handleSubscriptionUpdated(subscription: Stripe.Subscription): Promise<void> {\n        const tenantId = subscription.metadata?.tenantId;\n\n        if (!tenantId) {\n            return;\n        }\n\n        // Map Stripe status to our status\n        const statusMap: Record<string, SubscriptionStatus> = {\n            active: SubscriptionStatus.ACTIVE,\n            trialing: SubscriptionStatus.TRIALING,\n            past_due: SubscriptionStatus.PAST_DUE,\n            canceled: SubscriptionStatus.CANCELED,\n            unpaid: SubscriptionStatus.UNPAID,\n        };\n\n        const status = statusMap[subscription.status];\n\n        if (!status) {\n            return;\n        }\n\n        // TODO: Update subscription in database\n        console.log('Subscription updated', { tenantId, status });\n    }\n\n    /**\n     * Handle subscription deleted\n     */\n    private async handleSubscriptionDeleted(subscription: Stripe.Subscription): Promise<void> {\n        const tenantId = subscription.metadata?.tenantId;\n\n        if (!tenantId) {\n            return;\n        }\n\n        // TODO: Update subscription to canceled in database\n        console.log('Subscription deleted', { tenantId });\n    }\n\n    /**\n     * Handle invoice paid\n     */\n    private async handleInvoicePaid(invoice: Stripe.Invoice): Promise<void> {\n        const subscriptionId = invoice.subscription as string;\n\n        if (!subscriptionId) {\n            return;\n        }\n\n        // TODO: Update subscription status to active\n        console.log('Invoice paid', { subscriptionId });\n    }\n\n    /**\n     * Handle invoice payment failed\n     */\n    private async handleInvoicePaymentFailed(invoice: Stripe.Invoice): Promise<void> {\n        const subscriptionId = invoice.subscription as string;\n\n        if (!subscriptionId) {\n            return;\n        }\n\n        // TODO: Update subscription status to past_due\n        console.log('Invoice payment failed', { subscriptionId });\n    }\n\n    /**\n     * Get customer ID for tenant\n     */\n    private async getCustomerId(tenantId: string): Promise<string | null> {\n        const customers = await this.stripe.customers.list({\n            metadata: { tenantId },\n            limit: 1,\n        });\n\n        return customers.data[0]?.id || null;\n    }\n\n    /**\n     * Get price for plan\n     */\n    private getPlanPrice(plan: SubscriptionPlan): Stripe.Price {\n        const priceMap: Record<SubscriptionPlan, string> = {\n            [SubscriptionPlan.BASIC]: this.configService.get('STRIPE_PRICE_BASIC')!,\n            [SubscriptionPlan.PROFESSIONAL]: this.configService.get('STRIPE_PRICE_PROFESSIONAL')!,\n            [SubscriptionPlan.ENTERPRISE]: this.configService.get('STRIPE_PRICE_ENTERPRISE')!,\n        };\n\n        const priceId = priceMap[plan];\n\n        if (!priceId) {\n            throw new InternalServerErrorException(`Price not configured for plan: ${plan}`);\n        }\n\n        return this.stripe.prices.retrieve(priceId);\n    }\n\n    /**\n     * Get all prices for plan\n     */\n    private getPlanPrices(plan: SubscriptionPlan): Stripe.Price[] {\n        const prices = this.getPlanPrice(plan);\n        return [prices];\n    }\n}\n"],"names":["StripeService","createCheckoutSession","tenantId","dto","prices","getPlanPrices","plan","customerId","getCustomerId","customer","stripe","customers","create","metadata","id","session","checkout","sessions","payment_method_types","line_items","map","price","quantity","mode","success_url","successUrl","configService","get","cancel_url","cancelUrl","subscription_data","trial_period_days","trial","undefined","allow_promotion_codes","auditService","log","action","entityType","entityId","checkoutUrl","url","sessionId","createPortalSession","returnUrl","BadRequestException","billingPortal","return_url","cancelSubscription","subscriptionId","atPeriodEnd","subscriptions","update","cancel_at_period_end","resumeSubscription","updateSubscriptionPlan","getPlanPrice","items","retrieve","data","proration_behavior","handleWebhook","payload","signature","webhookSecret","Error","event","webhooks","constructEvent","error","type","handleCheckoutSessionCompleted","object","handleSubscriptionCreated","handleSubscriptionUpdated","handleSubscriptionDeleted","handleInvoicePaid","handleInvoicePaymentFailed","console","InternalServerErrorException","subscription","statusMap","active","SubscriptionStatus","ACTIVE","trialing","TRIALING","past_due","PAST_DUE","canceled","CANCELED","unpaid","UNPAID","status","invoice","list","limit","priceMap","SubscriptionPlan","BASIC","PROFESSIONAL","ENTERPRISE","priceId","secretKey","Stripe","apiVersion"],"mappings":"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"}