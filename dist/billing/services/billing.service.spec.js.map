{"version":3,"sources":["../../../src/billing/services/billing.service.spec.ts"],"sourcesContent":["import { Test, TestingModule } from '@nestjs/testing';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { BillingService } from './billing.service';\nimport { StripeService } from './stripe.service';\nimport { WayForPayService } from './wayforpay.service';\nimport { Subscription } from '../../database/entities/Subscription.entity';\nimport { SubscriptionStatus, SubscriptionPlan, SubscriptionProvider } from '../../database/entities/enums/subscription.enum';\n\ndescribe('BillingService', () => {\n    let service: BillingService;\n    let subscriptionRepository: jest.Mocked<Repository<Subscription>>;\n    let stripeService: jest.Mocked<StripeService>;\n    let wayForPayService: jest.Mocked<WayForPayService>;\n\n    const mockTenantId = 'test-tenant-id';\n    const mockSubscriptionId = 'test-subscription-id';\n    const mockExternalId = 'ext_sub_123456';\n\n    const mockSubscription: Subscription = {\n        id: mockSubscriptionId,\n        tenantId: mockTenantId,\n        provider: SubscriptionProvider.STRIPE,\n        externalId: 'cus_123',\n        subscriptionExternalId: mockExternalId,\n        plan: SubscriptionPlan.PROFESSIONAL,\n        status: SubscriptionStatus.ACTIVE,\n        trialStartAt: null,\n        trialEndAt: null,\n        currentPeriodStartAt: new Date(),\n        currentPeriodEndAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n        cancelAtPeriodEnd: false,\n        canceledAt: null,\n        amountCents: 2999,\n        currency: 'USD',\n        lastSyncedAt: new Date(),\n    } as Subscription;\n\n    beforeEach(async () => {\n        const module: TestingModule = await Test.createTestingModule({\n            providers: [\n                BillingService,\n                {\n                    provide: getRepositoryToken(Subscription),\n                    useValue: {\n                        findOne: jest.fn(),\n                        update: jest.fn(),\n                        save: jest.fn(),\n                        create: jest.fn(),\n                    },\n                },\n                {\n                    provide: StripeService,\n                    useValue: {\n                        cancelSubscription: jest.fn(),\n                        resumeSubscription: jest.fn(),\n                        updateSubscriptionPlan: jest.fn(),\n                        getInvoices: jest.fn(),\n                        getPaymentMethods: jest.fn(),\n                    },\n                },\n                {\n                    provide: WayForPayService,\n                    useValue: {\n                        createPayment: jest.fn(),\n                        verifyPayment: jest.fn(),\n                    },\n                },\n            ],\n        }).compile();\n\n        service = module.get<BillingService>(BillingService);\n        subscriptionRepository = module.get(getRepositoryToken(Subscription));\n        stripeService = module.get(StripeService);\n        wayForPayService = module.get(WayForPayService);\n    });\n\n    afterEach(() => {\n        jest.clearAllMocks();\n    });\n\n    describe('getSubscription', () => {\n        it('should return subscription for tenant', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n\n            const result = await service.getSubscription(mockTenantId);\n\n            expect(result).toEqual(mockSubscription);\n            expect(subscriptionRepository.findOne).toHaveBeenCalledWith({\n                where: { tenantId: mockTenantId },\n            });\n        });\n\n        it('should return null if subscription not found', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(null);\n\n            const result = await service.getSubscription(mockTenantId);\n\n            expect(result).toBeNull();\n        });\n    });\n\n    describe('cancelSubscription', () => {\n        it('should cancel subscription immediately via Stripe', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n            stripeService.cancelSubscription.mockResolvedValue();\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.cancelSubscription(mockTenantId, false);\n\n            expect(stripeService.cancelSubscription).toHaveBeenCalledWith(mockExternalId, false);\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { id: mockSubscriptionId },\n                {\n                    status: SubscriptionStatus.CANCELED,\n                    canceledAt: expect.any(Date),\n                }\n            );\n        });\n\n        it('should cancel subscription at period end via Stripe', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n            stripeService.cancelSubscription.mockResolvedValue();\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.cancelSubscription(mockTenantId, true);\n\n            expect(stripeService.cancelSubscription).toHaveBeenCalledWith(mockExternalId, true);\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { id: mockSubscriptionId },\n                {\n                    cancelAtPeriodEnd: true,\n                }\n            );\n        });\n\n        it('should handle subscription without Stripe external ID', async () => {\n            const localSubscription = {\n                ...mockSubscription,\n                provider: SubscriptionProvider.WAYFORPAY,\n                subscriptionExternalId: null,\n            };\n            subscriptionRepository.findOne.mockResolvedValue(localSubscription);\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.cancelSubscription(mockTenantId, false);\n\n            expect(stripeService.cancelSubscription).not.toHaveBeenCalled();\n            expect(subscriptionRepository.update).toHaveBeenCalled();\n        });\n    });\n\n    describe('resumeSubscription', () => {\n        it('should resume subscription via Stripe', async () => {\n            const canceledSubscription = {\n                ...mockSubscription,\n                status: SubscriptionStatus.CANCELED,\n                cancelAtPeriodEnd: true,\n            };\n            subscriptionRepository.findOne.mockResolvedValue(canceledSubscription);\n            stripeService.resumeSubscription.mockResolvedValue();\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.resumeSubscription(mockTenantId);\n\n            expect(stripeService.resumeSubscription).toHaveBeenCalledWith(mockExternalId);\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { id: mockSubscriptionId },\n                {\n                    status: SubscriptionStatus.ACTIVE,\n                    plan: canceledSubscription.plan,\n                    cancelAtPeriodEnd: false,\n                    canceledAt: null,\n                }\n            );\n        });\n\n        it('should resume and upgrade subscription plan', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n            stripeService.resumeSubscription.mockResolvedValue();\n            stripeService.updateSubscriptionPlan.mockResolvedValue();\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.resumeSubscription(mockTenantId, SubscriptionPlan.ENTERPRISE);\n\n            expect(stripeService.updateSubscriptionPlan).toHaveBeenCalledWith(\n                mockExternalId,\n                SubscriptionPlan.ENTERPRISE\n            );\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { id: mockSubscriptionId },\n                {\n                    status: SubscriptionStatus.ACTIVE,\n                    plan: SubscriptionPlan.ENTERPRISE,\n                    cancelAtPeriodEnd: false,\n                    canceledAt: null,\n                }\n            );\n        });\n    });\n\n    describe('getInvoices', () => {\n        it('should return empty array for Stripe subscription', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n\n            const result = await service.getInvoices(mockTenantId);\n\n            expect(result).toEqual([]);\n        });\n\n        it('should return empty array for non-Stripe subscription', async () => {\n            const wayforpaySubscription = {\n                ...mockSubscription,\n                provider: SubscriptionProvider.WAYFORPAY,\n            };\n            subscriptionRepository.findOne.mockResolvedValue(wayforpaySubscription);\n\n            const result = await service.getInvoices(mockTenantId);\n\n            expect(result).toEqual([]);\n        });\n    });\n\n    describe('getPaymentMethods', () => {\n        it('should return empty array for Stripe subscription', async () => {\n            subscriptionRepository.findOne.mockResolvedValue(mockSubscription);\n\n            const result = await service.getPaymentMethods(mockTenantId);\n\n            expect(result).toEqual([]);\n        });\n    });\n\n    describe('updateSubscriptionFromWebhook', () => {\n        it('should update subscription from webhook data', async () => {\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.updateSubscriptionFromWebhook(\n                mockExternalId,\n                SubscriptionProvider.STRIPE,\n                {\n                    status: SubscriptionStatus.ACTIVE,\n                    plan: SubscriptionPlan.ENTERPRISE,\n                    currentPeriodEndAt: new Date('2024-12-31'),\n                    amountCents: 4999,\n                    currency: 'USD',\n                }\n            );\n\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { subscriptionExternalId: mockExternalId, provider: SubscriptionProvider.STRIPE },\n                {\n                    status: SubscriptionStatus.ACTIVE,\n                    plan: SubscriptionPlan.ENTERPRISE,\n                    currentPeriodEndAt: expect.any(Date),\n                    amountCents: 4999,\n                    currency: 'USD',\n                    lastSyncedAt: expect.any(Date),\n                }\n            );\n        });\n\n        it('should update only provided fields', async () => {\n            subscriptionRepository.update.mockResolvedValue({} as any);\n\n            await service.updateSubscriptionFromWebhook(\n                mockExternalId,\n                SubscriptionProvider.STRIPE,\n                {\n                    status: SubscriptionStatus.PAST_DUE,\n                }\n            );\n\n            expect(subscriptionRepository.update).toHaveBeenCalledWith(\n                { subscriptionExternalId: mockExternalId, provider: SubscriptionProvider.STRIPE },\n                {\n                    status: SubscriptionStatus.PAST_DUE,\n                    lastSyncedAt: expect.any(Date),\n                }\n            );\n        });\n    });\n\n    describe('createSubscriptionFromWebhook', () => {\n        it('should create subscription from webhook data', async () => {\n            subscriptionRepository.save.mockResolvedValue({} as any);\n\n            await service.createSubscriptionFromWebhook(\n                mockTenantId,\n                mockExternalId,\n                SubscriptionProvider.STRIPE,\n                {\n                    plan: SubscriptionPlan.PROFESSIONAL,\n                    status: SubscriptionStatus.ACTIVE,\n                    trialStartAt: new Date(),\n                    trialEndAt: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000),\n                    currentPeriodStartAt: new Date(),\n                    currentPeriodEndAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n                    amountCents: 2999,\n                    currency: 'USD',\n                }\n            );\n\n            expect(subscriptionRepository.save).toHaveBeenCalledWith({\n                tenantId: mockTenantId,\n                provider: SubscriptionProvider.STRIPE,\n                externalId: mockExternalId,\n                subscriptionExternalId: mockExternalId,\n                plan: SubscriptionPlan.PROFESSIONAL,\n                status: SubscriptionStatus.ACTIVE,\n                trialStartAt: expect.any(Date),\n                trialEndAt: expect.any(Date),\n                currentPeriodStartAt: expect.any(Date),\n                currentPeriodEndAt: expect.any(Date),\n                amountCents: 2999,\n                currency: 'USD',\n                lastSyncedAt: expect.any(Date),\n            });\n        });\n\n        it('should create subscription with minimal data', async () => {\n            subscriptionRepository.save.mockResolvedValue({} as any);\n\n            await service.createSubscriptionFromWebhook(\n                mockTenantId,\n                mockExternalId,\n                SubscriptionProvider.WAYFORPAY,\n                {\n                    plan: SubscriptionPlan.BASIC,\n                    status: SubscriptionStatus.TRIALING,\n                }\n            );\n\n            expect(subscriptionRepository.save).toHaveBeenCalledWith({\n                tenantId: mockTenantId,\n                provider: SubscriptionProvider.WAYFORPAY,\n                externalId: mockExternalId,\n                subscriptionExternalId: mockExternalId,\n                plan: SubscriptionPlan.BASIC,\n                status: SubscriptionStatus.TRIALING,\n                lastSyncedAt: expect.any(Date),\n            });\n        });\n    });\n});\n"],"names":["describe","service","subscriptionRepository","stripeService","wayForPayService","mockTenantId","mockSubscriptionId","mockExternalId","mockSubscription","id","tenantId","provider","SubscriptionProvider","STRIPE","externalId","subscriptionExternalId","plan","SubscriptionPlan","PROFESSIONAL","status","SubscriptionStatus","ACTIVE","trialStartAt","trialEndAt","currentPeriodStartAt","Date","currentPeriodEndAt","now","cancelAtPeriodEnd","canceledAt","amountCents","currency","lastSyncedAt","beforeEach","module","Test","createTestingModule","providers","BillingService","provide","getRepositoryToken","Subscription","useValue","findOne","jest","fn","update","save","create","StripeService","cancelSubscription","resumeSubscription","updateSubscriptionPlan","getInvoices","getPaymentMethods","WayForPayService","createPayment","verifyPayment","compile","get","afterEach","clearAllMocks","it","mockResolvedValue","result","getSubscription","expect","toEqual","toHaveBeenCalledWith","where","toBeNull","CANCELED","any","localSubscription","WAYFORPAY","not","toHaveBeenCalled","canceledSubscription","ENTERPRISE","wayforpaySubscription","updateSubscriptionFromWebhook","PAST_DUE","createSubscriptionFromWebhook","BASIC","TRIALING"],"mappings":"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"}