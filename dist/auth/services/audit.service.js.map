{"version":3,"sources":["../../../src/auth/services/audit.service.ts"],"sourcesContent":["import { Injectable, CanActivate, ExecutionContext, Logger } from '@nestjs/common';\nimport { AuditLog } from '../../database/entities/AuditLog.entity';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { JwtPayload } from '../interfaces/jwt.interface';\n\n/**\n * Audit Logging Decorator Factory\n */\nexport const Audit = (action: string) => {\n    return function (\n        target: any,\n        propertyKey: string,\n        descriptor: PropertyDescriptor\n    ) {\n        const originalMethod = descriptor.value;\n\n        descriptor.value = async function (...args: any[]) {\n            const context: ExecutionContext = args[2]; // ExecutionContext is typically the 3rd argument\n\n            if (context) {\n                const request = context.switchToHttp().getRequest();\n                const auditService: AuditService = (this as any).auditService;\n\n                try {\n                    const result = await originalMethod.apply(this, args);\n\n                    // Log successful action\n                    await auditService.log({\n                        tenantId: request.user?.tenant_id,\n                        userId: request.user?.user_id,\n                        action: action as any,\n                        entityType: target.constructor.name,\n                        entityId: result?.id,\n                        ipAddress: request.ip,\n                        userAgent: request.get('user-agent'),\n                        requestId: request.correlationId,\n                        metadata: {\n                            endpoint: request.route?.path,\n                            method: request.method,\n                        },\n                    });\n\n                    return result;\n                } catch (error) {\n                    // Log failed action\n                    const auditService: AuditService = (this as any).auditService;\n\n                    await auditService.log({\n                        tenantId: request.user?.tenant_id,\n                        userId: request.user?.user_id,\n                        action: 'login' as any, // Generic action for failures\n                        entityType: target.constructor.name,\n                        ipAddress: request.ip,\n                        userAgent: request.get('user-agent'),\n                        requestId: request.correlationId,\n                        metadata: {\n                            endpoint: request.route?.path,\n                            method: request.method,\n                            error: error.message,\n                        },\n                    });\n\n                    throw error;\n                }\n            } else {\n                return originalMethod.apply(this, args);\n            }\n        };\n\n        return descriptor;\n    };\n};\n\n/**\n * Audit Service\n */\n@Injectable()\nexport class AuditService {\n    private readonly logger = new Logger(AuditService.name);\n\n    constructor(\n        @InjectRepository(AuditLog)\n        private readonly auditLogRepository: Repository<AuditLog>,\n    ) {}\n\n    /**\n     * Log an audit event\n     */\n    async log(data: {\n        tenantId: string;\n        userId?: string;\n        action: any;\n        entityType: string;\n        entityId?: string;\n        oldValues?: Record<string, any>;\n        newValues?: Record<string, any>;\n        changedFields?: string[];\n        ipAddress?: string;\n        userAgent?: string;\n        requestId?: string;\n        metadata?: Record<string, any>;\n    }): Promise<void> {\n        try {\n            const auditLog = this.auditLogRepository.create({\n                tenantId: data.tenantId,\n                userId: data.userId,\n                action: data.action,\n                entityType: data.entityType,\n                entityId: data.entityId,\n                oldValues: data.oldValues,\n                newValues: data.newValues,\n                changedFields: data.changedFields,\n                ipAddress: data.ipAddress,\n                userAgent: data.userAgent,\n                requestId: data.requestId,\n                metadata: data.metadata,\n            });\n\n            await this.auditLogRepository.save(auditLog);\n\n            this.logger.debug(`Audit log created: ${data.action} on ${data.entityType}`);\n        } catch (error) {\n            // Don't throw error in audit logging to avoid breaking main flow\n            this.logger.error('Failed to create audit log:', error);\n        }\n    }\n\n    /**\n     * Get audit logs for a tenant\n     */\n    async getTenantAuditLogs(\n        tenantId: string,\n        filters: {\n            userId?: string;\n            action?: string;\n            entityType?: string;\n            startDate?: Date;\n            endDate?: Date;\n            page?: number;\n            limit?: number;\n        } = {}\n    ): Promise<{ data: AuditLog[]; total: number }> {\n        const query = this.auditLogRepository\n            .createQueryBuilder('auditLog')\n            .where('auditLog.tenantId = :tenantId', { tenantId });\n\n        if (filters.userId) {\n            query.andWhere('auditLog.userId = :userId', { userId: filters.userId });\n        }\n\n        if (filters.action) {\n            query.andWhere('auditLog.action = :action', { action: filters.action });\n        }\n\n        if (filters.entityType) {\n            query.andWhere('auditLog.entityType = :entityType', {\n                entityType: filters.entityType,\n            });\n        }\n\n        if (filters.startDate) {\n            query.andWhere('auditLog.createdAt >= :startDate', { startDate: filters.startDate });\n        }\n\n        if (filters.endDate) {\n            query.andWhere('auditLog.createdAt <= :endDate', { endDate: filters.endDate });\n        }\n\n        const page = filters.page || 1;\n        const limit = filters.limit || 50;\n\n        const [data, total] = await query\n            .orderBy('auditLog.createdAt', 'DESC')\n            .skip((page - 1) * limit)\n            .take(limit)\n            .getManyAndCount();\n\n        return { data, total };\n    }\n\n    /**\n     * Calculate changed fields\n     */\n    calculateChangedFields(oldValues: Record<string, any>, newValues: Record<string, any>): string[] {\n        const changedFields: string[] = [];\n\n        const allKeys = new Set([...Object.keys(oldValues), ...Object.keys(newValues)]);\n\n        for (const key of allKeys) {\n            const oldValue = oldValues[key];\n            const newValue = newValues[key];\n\n            if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {\n                changedFields.push(key);\n            }\n        }\n\n        return changedFields;\n    }\n\n    /**\n     * Purge old audit logs (retention policy)\n     */\n    async purgeOldAuditLogs(retentionDays: number = 90): Promise<number> {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - retentionDays);\n\n        const result = await this.auditLogRepository\n            .createQueryBuilder()\n            .delete()\n            .where('createdAt < :cutoffDate', { cutoffDate })\n            .execute();\n\n        this.logger.log(`Purged ${result.affected} audit logs older than ${retentionDays} days`);\n\n        return result.affected || 0;\n    }\n}\n"],"names":["Audit","AuditService","action","target","propertyKey","descriptor","originalMethod","value","args","context","request","switchToHttp","getRequest","auditService","result","apply","log","tenantId","user","tenant_id","userId","user_id","entityType","name","entityId","id","ipAddress","ip","userAgent","get","requestId","correlationId","metadata","endpoint","route","path","method","error","message","data","auditLog","auditLogRepository","create","oldValues","newValues","changedFields","save","logger","debug","getTenantAuditLogs","filters","query","createQueryBuilder","where","andWhere","startDate","endDate","page","limit","total","orderBy","skip","take","getManyAndCount","calculateChangedFields","allKeys","Set","Object","keys","key","oldValue","newValue","JSON","stringify","push","purgeOldAuditLogs","retentionDays","cutoffDate","Date","setDate","getDate","delete","execute","affected","Logger"],"mappings":"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"}