{"version":3,"sources":["../../../src/file-storage/services/file-storage.service.ts"],"sourcesContent":["import { Injectable, Logger, BadRequestException } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { StorageProviderService } from './storage-provider.service';\nimport { FileUploadOptions, FileUploadResult, StorageQuota } from '../interfaces/file-storage.interfaces';\nimport * as crypto from 'crypto';\n\n/**\n * Allowed file types for upload\n */\nconst ALLOWED_MIME_TYPES = [\n    'application/pdf',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/vnd.ms-excel',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'image/jpeg',\n    'image/jpg',\n    'image/png',\n    'image/gif',\n];\n\n/**\n * Maximum file size per plan (in bytes)\n */\nconst PLAN_LIMITS: Record<string, number> = {\n    basic: 10 * 1024 * 1024, // 10 MB\n    professional: 50 * 1024 * 1024, // 50 MB\n    enterprise: 100 * 1024 * 1024, // 100 MB\n};\n\n/**\n * Storage quotas per plan (in GB)\n */\nconst STORAGE_QUOTAS: Record<string, number> = {\n    basic: 1, // 1 GB\n    professional: 10, // 10 GB\n    enterprise: 100, // 100 GB\n};\n\n/**\n * File Storage Service\n *\n * High-level service that provides business logic for file operations\n */\n@Injectable()\nexport class FileStorageService {\n    private readonly logger = new Logger(FileStorageService.name);\n\n    constructor(\n        private readonly configService: ConfigService,\n        private readonly storageProvider: StorageProviderService,\n    ) {}\n\n    /**\n     * Upload file with validation and quota check\n     */\n    async uploadFile(\n        tenantId: string,\n        userId: string,\n        file: Express.Multer.File,\n        options: {\n            caseId?: string;\n            clientId?: string;\n            folder?: string;\n            isPublic?: boolean;\n            metadata?: Record<string, string>;\n        } = {}\n    ): Promise<FileUploadResult> {\n        // Validate file type\n        if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {\n            throw new BadRequestException(`Unsupported file type: ${file.mimetype}`);\n        }\n\n        // Validate file size (basic check)\n        const maxSize = PLAN_LIMITS.basic; // Default to basic limit\n        if (file.size > maxSize) {\n            throw new BadRequestException(`File too large. Maximum size is ${maxSize / (1024 * 1024)} MB`);\n        }\n\n        // Generate unique file name\n        const fileExtension = file.originalname.split('.').pop();\n        const fileName = `${crypto.randomUUID()}.${fileExtension}`;\n\n        // Build storage path\n        const path = this.buildStoragePath(tenantId, options.folder, options.caseId, options.clientId);\n\n        // Prepare upload options\n        const uploadOptions: FileUploadOptions = {\n            path,\n            fileName,\n            buffer: file.buffer,\n            contentType: file.mimetype,\n            metadata: {\n                originalName: file.originalname,\n                uploadedBy: userId,\n                ...options.metadata,\n            },\n            isPublic: options.isPublic || false,\n        };\n\n        // Upload file\n        const result = await this.storageProvider.upload(uploadOptions);\n\n        this.logger.log(`File uploaded for tenant ${tenantId}: ${fileName}`);\n        return result;\n    }\n\n    /**\n     * Upload multiple files\n     */\n    async uploadFiles(\n        tenantId: string,\n        userId: string,\n        files: Express.Multer.File[],\n        options: {\n            caseId?: string;\n            clientId?: string;\n            folder?: string;\n            isPublic?: boolean;\n        } = {}\n    ): Promise<{ success: FileUploadResult[]; failed: Array<{ fileName: string; error: string }> }> {\n        const results = {\n            success: [] as FileUploadResult[],\n            failed: [] as Array<{ fileName: string; error: string }>,\n        };\n\n        for (const file of files) {\n            try {\n                const result = await this.uploadFile(tenantId, userId, file, options);\n                results.success.push(result);\n            } catch (error) {\n                results.failed.push({\n                    fileName: file.originalname,\n                    error: error.message || 'Upload failed',\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Download file\n     */\n    async downloadFile(tenantId: string, storagePath: string): Promise<Buffer> {\n        this.validateTenantAccess(storagePath, tenantId);\n\n        const result = await this.storageProvider.download({ path: storagePath });\n        return result.buffer;\n    }\n\n    /**\n     * Generate signed URL for file\n     */\n    async generateSignedUrl(\n        tenantId: string,\n        storagePath: string,\n        options: {\n            expiresIn?: number;\n            disposition?: 'attachment' | 'inline';\n            contentType?: string;\n        } = {}\n    ): Promise<string> {\n        this.validateTenantAccess(storagePath, tenantId);\n\n        return this.storageProvider.generateSignedUrl({\n            path: storagePath,\n            expiresIn: options.expiresIn,\n            disposition: options.disposition,\n            contentType: options.contentType,\n        });\n    }\n\n    /**\n     * Delete file\n     */\n    async deleteFile(tenantId: string, storagePath: string): Promise<void> {\n        this.validateTenantAccess(storagePath, tenantId);\n\n        await this.storageProvider.delete(storagePath);\n        this.logger.log(`File deleted for tenant ${tenantId}: ${storagePath}`);\n    }\n\n    /**\n     * Delete multiple files\n     */\n    async deleteFiles(tenantId: string, storagePaths: string[]): Promise<void> {\n        // Validate all paths belong to the tenant\n        for (const path of storagePaths) {\n            this.validateTenantAccess(path, tenantId);\n        }\n\n        await this.storageProvider.deleteMultiple(storagePaths);\n        this.logger.log(`Deleted ${storagePaths.length} files for tenant ${tenantId}`);\n    }\n\n    /**\n     * Copy file\n     */\n    async copyFile(\n        tenantId: string,\n        sourcePath: string,\n        destinationPath: string\n    ): Promise<FileUploadResult> {\n        this.validateTenantAccess(sourcePath, tenantId);\n        this.validateTenantAccess(destinationPath, tenantId);\n\n        return this.storageProvider.copy(sourcePath, destinationPath);\n    }\n\n    /**\n     * Move file\n     */\n    async moveFile(\n        tenantId: string,\n        sourcePath: string,\n        destinationPath: string\n    ): Promise<FileUploadResult> {\n        this.validateTenantAccess(sourcePath, tenantId);\n        this.validateTenantAccess(destinationPath, tenantId);\n\n        return this.storageProvider.move(sourcePath, destinationPath);\n    }\n\n    /**\n     * Check if file exists\n     */\n    async fileExists(tenantId: string, storagePath: string): Promise<boolean> {\n        this.validateTenantAccess(storagePath, tenantId);\n\n        return this.storageProvider.exists(storagePath);\n    }\n\n    /**\n     * Get file metadata\n     */\n    async getFileMetadata(tenantId: string, storagePath: string) {\n        this.validateTenantAccess(storagePath, tenantId);\n\n        return this.storageProvider.getMetadata(storagePath);\n    }\n\n    /**\n     * Get storage quota for tenant\n     */\n    async getStorageQuota(tenantId: string, plan: string = 'basic'): Promise<StorageQuota> {\n        const quotaGB = STORAGE_QUOTAS[plan] || STORAGE_QUOTAS.basic;\n        const total = quotaGB * 1024 * 1024 * 1024;\n\n        const prefix = `tenants/${tenantId}/`;\n        const used = await this.storageProvider.getStorageUsage(prefix);\n\n        return {\n            total,\n            used,\n            available: total - used,\n            usagePercentage: (used / total) * 100,\n        };\n    }\n\n    /**\n     * Validate file before upload\n     */\n    validateFile(file: Express.Multer.File): { valid: boolean; error?: string } {\n        if (!file) {\n            return { valid: false, error: 'No file provided' };\n        }\n\n        if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {\n            return { valid: false, error: `Unsupported file type: ${file.mimetype}` };\n        }\n\n        if (file.size > PLAN_LIMITS.basic) {\n            return {\n                valid: false,\n                error: `File too large. Maximum size is ${PLAN_LIMITS.basic / (1024 * 1024)} MB`,\n            };\n        }\n\n        return { valid: true };\n    }\n\n    /**\n     * Get allowed MIME types\n     */\n    getAllowedMimeTypes(): string[] {\n        return ALLOWED_MIME_TYPES;\n    }\n\n    /**\n     * Get file size limit for a plan\n     */\n    getFileSizeLimit(plan: string = 'basic'): number {\n        return PLAN_LIMITS[plan] || PLAN_LIMITS.basic;\n    }\n\n    /**\n     * Build storage path\n     */\n    private buildStoragePath(\n        tenantId: string,\n        folder?: string,\n        caseId?: string,\n        clientId?: string\n    ): string {\n        let path = `tenants/${tenantId}/`;\n\n        if (folder) {\n            path += `${folder}/`;\n        }\n\n        if (caseId) {\n            path += `cases/${caseId}/`;\n        }\n\n        if (clientId) {\n            path += `clients/${clientId}/`;\n        }\n\n        return path;\n    }\n\n    /**\n     * Validate tenant access to storage path\n     */\n    private validateTenantAccess(storagePath: string, tenantId: string): void {\n        const tenantPrefix = `tenants/${tenantId}/`;\n        if (!storagePath.startsWith(tenantPrefix)) {\n            throw new BadRequestException('Access denied to file');\n        }\n    }\n}\n"],"names":["FileStorageService","ALLOWED_MIME_TYPES","PLAN_LIMITS","basic","professional","enterprise","STORAGE_QUOTAS","uploadFile","tenantId","userId","file","options","includes","mimetype","BadRequestException","maxSize","size","fileExtension","originalname","split","pop","fileName","crypto","randomUUID","path","buildStoragePath","folder","caseId","clientId","uploadOptions","buffer","contentType","metadata","originalName","uploadedBy","isPublic","result","storageProvider","upload","logger","log","uploadFiles","files","results","success","failed","push","error","message","downloadFile","storagePath","validateTenantAccess","download","generateSignedUrl","expiresIn","disposition","deleteFile","delete","deleteFiles","storagePaths","deleteMultiple","length","copyFile","sourcePath","destinationPath","copy","moveFile","move","fileExists","exists","getFileMetadata","getMetadata","getStorageQuota","plan","quotaGB","total","prefix","used","getStorageUsage","available","usagePercentage","validateFile","valid","getAllowedMimeTypes","getFileSizeLimit","tenantPrefix","startsWith","configService","Logger","name"],"mappings":";;;;+BA6CaA;;;eAAAA;;;wBA7C2C;wBAC1B;wCACS;gEAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAExB;;CAEC,GACD,MAAMC,qBAAqB;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AAED;;CAEC,GACD,MAAMC,cAAsC;IACxCC,OAAO,KAAK,OAAO;IACnBC,cAAc,KAAK,OAAO;IAC1BC,YAAY,MAAM,OAAO;AAC7B;AAEA;;CAEC,GACD,MAAMC,iBAAyC;IAC3CH,OAAO;IACPC,cAAc;IACdC,YAAY;AAChB;AAQO,IAAA,AAAML,qBAAN,MAAMA;IAQT;;KAEC,GACD,MAAMO,WACFC,QAAgB,EAChBC,MAAc,EACdC,IAAyB,EACzBC,UAMI,CAAC,CAAC,EACmB;QACzB,qBAAqB;QACrB,IAAI,CAACV,mBAAmBW,QAAQ,CAACF,KAAKG,QAAQ,GAAG;YAC7C,MAAM,IAAIC,2BAAmB,CAAC,CAAC,uBAAuB,EAAEJ,KAAKG,QAAQ,EAAE;QAC3E;QAEA,mCAAmC;QACnC,MAAME,UAAUb,YAAYC,KAAK,EAAE,yBAAyB;QAC5D,IAAIO,KAAKM,IAAI,GAAGD,SAAS;YACrB,MAAM,IAAID,2BAAmB,CAAC,CAAC,gCAAgC,EAAEC,UAAW,CAAA,OAAO,IAAG,EAAG,GAAG,CAAC;QACjG;QAEA,4BAA4B;QAC5B,MAAME,gBAAgBP,KAAKQ,YAAY,CAACC,KAAK,CAAC,KAAKC,GAAG;QACtD,MAAMC,WAAW,GAAGC,QAAOC,UAAU,GAAG,CAAC,EAAEN,eAAe;QAE1D,qBAAqB;QACrB,MAAMO,OAAO,IAAI,CAACC,gBAAgB,CAACjB,UAAUG,QAAQe,MAAM,EAAEf,QAAQgB,MAAM,EAAEhB,QAAQiB,QAAQ;QAE7F,yBAAyB;QACzB,MAAMC,gBAAmC;YACrCL;YACAH;YACAS,QAAQpB,KAAKoB,MAAM;YACnBC,aAAarB,KAAKG,QAAQ;YAC1BmB,UAAU;gBACNC,cAAcvB,KAAKQ,YAAY;gBAC/BgB,YAAYzB;gBACZ,GAAGE,QAAQqB,QAAQ;YACvB;YACAG,UAAUxB,QAAQwB,QAAQ,IAAI;QAClC;QAEA,cAAc;QACd,MAAMC,SAAS,MAAM,IAAI,CAACC,eAAe,CAACC,MAAM,CAACT;QAEjD,IAAI,CAACU,MAAM,CAACC,GAAG,CAAC,CAAC,yBAAyB,EAAEhC,SAAS,EAAE,EAAEa,UAAU;QACnE,OAAOe;IACX;IAEA;;KAEC,GACD,MAAMK,YACFjC,QAAgB,EAChBC,MAAc,EACdiC,KAA4B,EAC5B/B,UAKI,CAAC,CAAC,EACsF;QAC5F,MAAMgC,UAAU;YACZC,SAAS,EAAE;YACXC,QAAQ,EAAE;QACd;QAEA,KAAK,MAAMnC,QAAQgC,MAAO;YACtB,IAAI;gBACA,MAAMN,SAAS,MAAM,IAAI,CAAC7B,UAAU,CAACC,UAAUC,QAAQC,MAAMC;gBAC7DgC,QAAQC,OAAO,CAACE,IAAI,CAACV;YACzB,EAAE,OAAOW,OAAO;gBACZJ,QAAQE,MAAM,CAACC,IAAI,CAAC;oBAChBzB,UAAUX,KAAKQ,YAAY;oBAC3B6B,OAAOA,MAAMC,OAAO,IAAI;gBAC5B;YACJ;QACJ;QAEA,OAAOL;IACX;IAEA;;KAEC,GACD,MAAMM,aAAazC,QAAgB,EAAE0C,WAAmB,EAAmB;QACvE,IAAI,CAACC,oBAAoB,CAACD,aAAa1C;QAEvC,MAAM4B,SAAS,MAAM,IAAI,CAACC,eAAe,CAACe,QAAQ,CAAC;YAAE5B,MAAM0B;QAAY;QACvE,OAAOd,OAAON,MAAM;IACxB;IAEA;;KAEC,GACD,MAAMuB,kBACF7C,QAAgB,EAChB0C,WAAmB,EACnBvC,UAII,CAAC,CAAC,EACS;QACf,IAAI,CAACwC,oBAAoB,CAACD,aAAa1C;QAEvC,OAAO,IAAI,CAAC6B,eAAe,CAACgB,iBAAiB,CAAC;YAC1C7B,MAAM0B;YACNI,WAAW3C,QAAQ2C,SAAS;YAC5BC,aAAa5C,QAAQ4C,WAAW;YAChCxB,aAAapB,QAAQoB,WAAW;QACpC;IACJ;IAEA;;KAEC,GACD,MAAMyB,WAAWhD,QAAgB,EAAE0C,WAAmB,EAAiB;QACnE,IAAI,CAACC,oBAAoB,CAACD,aAAa1C;QAEvC,MAAM,IAAI,CAAC6B,eAAe,CAACoB,MAAM,CAACP;QAClC,IAAI,CAACX,MAAM,CAACC,GAAG,CAAC,CAAC,wBAAwB,EAAEhC,SAAS,EAAE,EAAE0C,aAAa;IACzE;IAEA;;KAEC,GACD,MAAMQ,YAAYlD,QAAgB,EAAEmD,YAAsB,EAAiB;QACvE,0CAA0C;QAC1C,KAAK,MAAMnC,QAAQmC,aAAc;YAC7B,IAAI,CAACR,oBAAoB,CAAC3B,MAAMhB;QACpC;QAEA,MAAM,IAAI,CAAC6B,eAAe,CAACuB,cAAc,CAACD;QAC1C,IAAI,CAACpB,MAAM,CAACC,GAAG,CAAC,CAAC,QAAQ,EAAEmB,aAAaE,MAAM,CAAC,kBAAkB,EAAErD,UAAU;IACjF;IAEA;;KAEC,GACD,MAAMsD,SACFtD,QAAgB,EAChBuD,UAAkB,EAClBC,eAAuB,EACE;QACzB,IAAI,CAACb,oBAAoB,CAACY,YAAYvD;QACtC,IAAI,CAAC2C,oBAAoB,CAACa,iBAAiBxD;QAE3C,OAAO,IAAI,CAAC6B,eAAe,CAAC4B,IAAI,CAACF,YAAYC;IACjD;IAEA;;KAEC,GACD,MAAME,SACF1D,QAAgB,EAChBuD,UAAkB,EAClBC,eAAuB,EACE;QACzB,IAAI,CAACb,oBAAoB,CAACY,YAAYvD;QACtC,IAAI,CAAC2C,oBAAoB,CAACa,iBAAiBxD;QAE3C,OAAO,IAAI,CAAC6B,eAAe,CAAC8B,IAAI,CAACJ,YAAYC;IACjD;IAEA;;KAEC,GACD,MAAMI,WAAW5D,QAAgB,EAAE0C,WAAmB,EAAoB;QACtE,IAAI,CAACC,oBAAoB,CAACD,aAAa1C;QAEvC,OAAO,IAAI,CAAC6B,eAAe,CAACgC,MAAM,CAACnB;IACvC;IAEA;;KAEC,GACD,MAAMoB,gBAAgB9D,QAAgB,EAAE0C,WAAmB,EAAE;QACzD,IAAI,CAACC,oBAAoB,CAACD,aAAa1C;QAEvC,OAAO,IAAI,CAAC6B,eAAe,CAACkC,WAAW,CAACrB;IAC5C;IAEA;;KAEC,GACD,MAAMsB,gBAAgBhE,QAAgB,EAAEiE,OAAe,OAAO,EAAyB;QACnF,MAAMC,UAAUpE,cAAc,CAACmE,KAAK,IAAInE,eAAeH,KAAK;QAC5D,MAAMwE,QAAQD,UAAU,OAAO,OAAO;QAEtC,MAAME,SAAS,CAAC,QAAQ,EAAEpE,SAAS,CAAC,CAAC;QACrC,MAAMqE,OAAO,MAAM,IAAI,CAACxC,eAAe,CAACyC,eAAe,CAACF;QAExD,OAAO;YACHD;YACAE;YACAE,WAAWJ,QAAQE;YACnBG,iBAAiB,AAACH,OAAOF,QAAS;QACtC;IACJ;IAEA;;KAEC,GACDM,aAAavE,IAAyB,EAAsC;QACxE,IAAI,CAACA,MAAM;YACP,OAAO;gBAAEwE,OAAO;gBAAOnC,OAAO;YAAmB;QACrD;QAEA,IAAI,CAAC9C,mBAAmBW,QAAQ,CAACF,KAAKG,QAAQ,GAAG;YAC7C,OAAO;gBAAEqE,OAAO;gBAAOnC,OAAO,CAAC,uBAAuB,EAAErC,KAAKG,QAAQ,EAAE;YAAC;QAC5E;QAEA,IAAIH,KAAKM,IAAI,GAAGd,YAAYC,KAAK,EAAE;YAC/B,OAAO;gBACH+E,OAAO;gBACPnC,OAAO,CAAC,gCAAgC,EAAE7C,YAAYC,KAAK,GAAI,CAAA,OAAO,IAAG,EAAG,GAAG,CAAC;YACpF;QACJ;QAEA,OAAO;YAAE+E,OAAO;QAAK;IACzB;IAEA;;KAEC,GACDC,sBAAgC;QAC5B,OAAOlF;IACX;IAEA;;KAEC,GACDmF,iBAAiBX,OAAe,OAAO,EAAU;QAC7C,OAAOvE,WAAW,CAACuE,KAAK,IAAIvE,YAAYC,KAAK;IACjD;IAEA;;KAEC,GACD,AAAQsB,iBACJjB,QAAgB,EAChBkB,MAAe,EACfC,MAAe,EACfC,QAAiB,EACX;QACN,IAAIJ,OAAO,CAAC,QAAQ,EAAEhB,SAAS,CAAC,CAAC;QAEjC,IAAIkB,QAAQ;YACRF,QAAQ,GAAGE,OAAO,CAAC,CAAC;QACxB;QAEA,IAAIC,QAAQ;YACRH,QAAQ,CAAC,MAAM,EAAEG,OAAO,CAAC,CAAC;QAC9B;QAEA,IAAIC,UAAU;YACVJ,QAAQ,CAAC,QAAQ,EAAEI,SAAS,CAAC,CAAC;QAClC;QAEA,OAAOJ;IACX;IAEA;;KAEC,GACD,AAAQ2B,qBAAqBD,WAAmB,EAAE1C,QAAgB,EAAQ;QACtE,MAAM6E,eAAe,CAAC,QAAQ,EAAE7E,SAAS,CAAC,CAAC;QAC3C,IAAI,CAAC0C,YAAYoC,UAAU,CAACD,eAAe;YACvC,MAAM,IAAIvE,2BAAmB,CAAC;QAClC;IACJ;IA1RA,YACI,AAAiByE,aAA4B,EAC7C,AAAiBlD,eAAuC,CAC1D;aAFmBkD,gBAAAA;aACAlD,kBAAAA;aAJJE,SAAS,IAAIiD,cAAM,CAACxF,mBAAmByF,IAAI;IAKzD;AAwRP"}