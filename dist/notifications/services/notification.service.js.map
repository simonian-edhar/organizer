{"version":3,"sources":["../../../src/notifications/services/notification.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';\n/**\n * Notification Service\n */\n@Injectable()\nexport class NotificationService {\n    constructor(\n        // Services will be injected when properly implemented\n    ) {}\n\n    /**\n     * Create notification\n     */\n    async create(\n        tenantId: string,\n        userId: string,\n        dto: {\n            type: 'email' | 'sms' | 'push' | 'in_app';\n            title: string;\n            body: string;\n            data?: Record<string, any>;\n            platform?: 'web' | 'mobile' | 'desktop';\n            priority?: 'normal' | 'high' | 'urgent';\n        }\n    ): Promise<any> {\n        const notification = {\n            tenantId,\n            userId,\n            type: dto.type,\n            title: dto.title,\n            body: dto.body,\n            status: 'pending',\n            priority: dto.priority || 'normal',\n            data: dto.data || {},\n        };\n\n        let createdNotification;\n\n        switch (dto.type) {\n            case 'email':\n                createdNotification = await this.sendEmailNotification(notification, dto);\n                break;\n            case 'sms':\n                createdNotification = await this.sendSmsNotification(notification, dto);\n                break;\n            case 'push':\n                createdNotification = await this.sendPushNotification(notification, dto);\n                break;\n            case 'in_app':\n                createdNotification = await this.sendInAppNotification(notification, dto);\n                break;\n        default:\n                createdNotification = await this.notificationTemplateRepository.save(notification);\n                break;\n        }\n\n        // TODO: Queue notification for delivery\n        await this.queueNotification(createdNotification);\n\n        return createdNotification;\n    }\n\n    /**\n     * Get user notifications\n     */\n    async getUserNotifications(\n        tenantId: string,\n        userId: string,\n        filters: {\n            type?: string;\n            status?: string;\n            platform?: string;\n            limit?: number;\n            page?: number;\n        } = {}\n    ): Promise<{ data: any[]; total: number; page: number; limit: number }> {\n        const query = this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .where('notification.tenantId = :tenantId AND notification.deletedAt IS NULL', { tenantId });\n\n        if (filters.type) {\n            query.andWhere('notification.type = :type', { type: filters.type });\n        }\n\n        if (filters.status) {\n            query.andWhere('notification.status = :status', { status: filters.status });\n        }\n\n        if (filters.platform) {\n            query.andWhere('notification.platform = :platform', { platform: filters.platform });\n        }\n\n        // Sorting\n        query.orderBy('notification.createdAt', 'DESC');\n\n        // Pagination\n        const page = filters.page || 1;\n        const limit = filters.limit || 20;\n        const skip = (page - 1) * limit;\n\n        query.skip(skip).take(limit);\n\n        // Include relations\n        query.leftJoinAndSelect('notification.user', 'user');\n        query.leftJoinAndSelect('notification.userEmail', 'userEmail');\n\n        const [data, total] = await query.getManyAndCount();\n\n        return {\n            data,\n            total,\n            page,\n            limit,\n        };\n    }\n\n    /**\n     * Mark notification as read\n     */\n    async markAsRead(\n        tenantId: string,\n        userId: string,\n        notificationId: string\n    ): Promise<void> {\n        const notification = await this.notificationTemplateRepository.findOne({\n            where: {\n                id: notificationId,\n                tenantId,\n                userId,\n                deletedAt: null,\n            },\n        });\n\n        if (!notification) {\n            throw new NotFoundException('Notification not found');\n        }\n\n        if (notification.userId !== userId) {\n            throw new ForbiddenException('You can only mark your own notifications as read');\n        }\n\n        notification.readAt = new Date();\n\n        await this.notificationTemplateRepository.save(notification);\n    }\n\n    /**\n     * Mark all notifications as read\n     */\n    async markAllAsRead(\n        tenantId: string,\n        userId: string,\n        filters: {\n            type?: string;\n        platform?: string;\n        beforeDate?: string;\n        afterDate?: string;\n        limit?: number;\n        batch_size?: number;\n        } = {}\n    ): Promise<number> {\n        const query = this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .where('notification.tenantId = :tenantId AND notification.userId = :userId AND notification.deletedAt IS NULL', {\n                tenantId,\n                userId,\n            });\n\n        if (filters.type) {\n            query.andWhere('notification.type = :type', { type: filters.type });\n        }\n\n        if (filters.platform) {\n            query.andWhere('notification.platform = :platform', { platform: filters.platform });\n        }\n\n        // Date range\n        if (filters.beforeDate && filters.afterDate) {\n            query.andWhere('notification.createdAt BETWEEN :beforeDate AND :afterDate', {\n                beforeDate: new Date(filters.beforeDate),\n                afterDate: new Date(filters.afterDate),\n            });\n        } else if (filters.beforeDate) {\n            query.andWhere('notification.createdAt >= :beforeDate', {\n                beforeDate: new Date(filters.beforeDate),\n            });\n        } else if (filters.afterDate) {\n            query.andWhere('notification.createdAt <= :afterDate', {\n                afterDate: new Date(filters.afterDate),\n            });\n        }\n\n        // Sorting\n        query.orderBy('notification.createdAt', 'DESC');\n\n        // Pagination\n        const limit = filters.limit || 100;\n        const batchSize = filters.batch_size || 100;\n\n        let markedCount = 0;\n\n        while (true) {\n            const notifications = await query\n                .where('notification.readAt IS NULL AND notification.deletedAt IS NULL')\n                .orderBy('notification.createdAt', 'DESC')\n                .limit(batchSize)\n                .getMany();\n\n            if (notifications.length === 0) {\n                break;\n            }\n\n            await this.notificationTemplateRepository.update(\n                { id: notifications.map(n => n.id) },\n                {\n                    readAt: new Date(),\n                    updatedBy: userId,\n                }\n            );\n\n            markedCount += notifications.length;\n        }\n\n        return markedCount;\n    }\n\n    /**\n     * Delete notification\n     */\n    async delete(tenantId: string, userId: string, notificationId: string): Promise<void> {\n        const notification = await this.notificationTemplateRepository.findOne({\n            where: {\n                id: notificationId,\n                tenantId,\n                userId,\n            },\n        });\n\n        if (!notification) {\n            throw new NotFoundException('Notification not found');\n        }\n\n        if (notification.userId !== userId) {\n            throw new ForbiddenException('You can only delete your own notifications');\n        }\n\n        // Soft delete\n        await this.notificationTemplateRepository.update(\n            { id },\n            {\n                deletedAt: new Date(),\n                updatedBy: userId,\n            }\n        );\n    }\n\n    /**\n     * Delete all notifications\n     */\n    async deleteAll(tenantId: string, userId: string): Promise<number> {\n        const result = await this.notificationTemplateRepository.update(\n            {\n                tenant_id: tenantId,\n                user_id: userId,\n            },\n            {\n                deleted_at: new Date(),\n                updated_by: userId,\n            }\n        );\n\n        return result.affected;\n    }\n\n    /**\n     * Get notification preferences\n     */\n    async getPreferences(\n        tenantId: string,\n        userId: string\n    ): Promise<{\n        email_enabled: boolean;\n        sms_enabled: boolean;\n        push_enabled: boolean;\n        email_digest_enabled: boolean;\n        sms_digest_enabled: boolean;\n        push_digest_enabled: boolean;\n        desktop_enabled: boolean;\n        mobile_enabled: boolean;\n        in_app_enabled: boolean;\n    }> {\n        const user = await this.userService.findById(tenantId, userId);\n\n        return {\n            email_enabled: true, // TODO: from preferences\n            sms_enabled: false, // TODO: from preferences\n            push_enabled: true, // TODO: from preferences\n            email_digest_enabled: true,\n            sms_digest_enabled: true,\n            push_digest_enabled: true,\n            desktop_enabled: true,\n            mobile_enabled: true,\n            in_app_enabled: true,\n        };\n    }\n\n    /**\n     * Update notification preferences\n     */\n    async updatePreferences(\n        tenantId: string,\n        userId: string,\n        preferences: {\n            email_enabled?: boolean;\n            sms_enabled?: boolean;\n            push_enabled?: boolean;\n            email_digest_enabled?: boolean;\n            sms_digest_enabled?: boolean;\n            push_digest_enabled?: boolean;\n            desktop_enabled?: boolean;\n            mobile_enabled?: boolean;\n            in_app_enabled?: boolean;\n            push_digest_enabled?: boolean;\n        }\n    ): Promise<void> {\n        await this.userService.updatePreferences(tenantId, userId, preferences);\n    }\n\n    /**\n     * Get unread count\n     */\n    async getUnreadCount(\n        tenantId: string,\n        userId: string\n    ): Promise<number> {\n        const count = await this.notificationTemplateRepository.count({\n            where: {\n                tenant_id: tenantId,\n                user_id: userId,\n                read_at: null,\n                deleted_at: null,\n            },\n        });\n\n        return count;\n    }\n\n    /**\n     * Send email notification\n     */\n    private async sendEmailNotification(\n        notification: any,\n        options: {\n            to?: string;\n            from_name?: string;\n            template_name: string;\n            template_data?: Record<string, any>;\n        } = {}\n    ): Promise<any> {\n        // TODO: Integrate with SendGrid/Mailgun/Resend\n        const { data } = await this.emailService.send({\n            to: options.to || notification.userEmail,\n            from_name: options.from_name || 'LAW ORGANIZER',\n            template_name: options.template_name,\n            template_data: options.template_data || {\n                user_name: notification.userFirstName || 'Користувач',\n                user_email: notification.userEmail,\n                action: notification.title,\n                ...options.template_data,\n            },\n        });\n\n        return data;\n    }\n\n    /**\n     * Send SMS notification\n     */\n    private async sendSmsNotification(\n        notification: any,\n        dto: any\n    ): Promise<any> {\n        // TODO: Integrate with Twilio/Viber/SMSFly\n        const { data } = await this.smsService.send({\n            to: dto.userPhone,\n            message: dto.body,\n        type: 'authentication',\n        priority: 'high',\n        template_data: {\n            code: dto.data?.verification_code,\n            user_name: notification.userFirstName || 'Користувач',\n            case_id: dto.data?.caseId,\n        event_id: dto.data?.eventId,\n        },\n        });\n\n        return data;\n    }\n\n    /**\n     * Send push notification\n     */\n    private async sendPushNotification(\n        notification: any\n    ): Promise<any> {\n        // TODO: Integrate with Firebase/APNS/OneSignal\n        const { data } = await this.pushService.send({\n            to: notification.deviceId,\n            title: notification.title,\n            body: notification.body,\n            data: notification.data || {},\n            platform: notification.platform || 'mobile', // Default to mobile\n        });\n\n        return data;\n    }\n\n    /**\n     * Send in-app notification\n     */\n    private async sendInAppNotification(\n        notification: any\n    ): Promise<any> {\n        // TODO: Integrate with React Native/Flutter\n        const { data } = await this.inAppService.send({\n            to: notification.userId,\n            title: notification.title,\n            body: notification.body,\n            data: notification.data || {},\n            notification_type: 'alert' | 'information',\n            platform: 'in_app',\n            priority: notification.priority || 'normal',\n        });\n\n        return data;\n    }\n\n    /**\n     * Queue notification for delivery\n     */\n    private async queueNotification(notification: any): Promise<void> {\n        // TODO: Implement with Bull/BullMQ\n        // Send to Redis queue for async processing\n        await this.notificationQueue.add({\n            jobName: 'send-notification',\n            data: {\n                notificationId: notification.id,\n                tenantId: notification.tenantId,\n            userId: notification.userId,\n                type: notification.type,\n            title: notification.title,\n                body: notification.body,\n                data: notification.data || {},\n                platform: notification.platform || 'web', // Default to web\n            },\n            options: {\n                attempts: 3,\n                backoff: {\n                    delay: 5000, // 5 seconds\n                    type: 'exponential',\n                    delay: 30000, // 30 seconds (max delay = 5 * 30 = 150s)\n                },\n            },\n        });\n    }\n\n    /**\n     * Mark notification as delivered\n     */\n    async markAsDelivered(\n        tenantId: string,\n        notificationId: string,\n        userId: string,\n        dto: {\n            platform?: 'web' | 'mobile' | 'desktop';\n            device_info?: Record<string, any>;\n        ip_address?: string;\n        user_agent?: string;\n        device_token?: string;\n    }\n    ): Promise<void> {\n        const notification = await this.notificationTemplateRepository.findOne({\n            where: {\n                id: notificationId,\n                tenantId,\n            deletedAt: null,\n            },\n        });\n\n        if (!notification) {\n            throw new NotFoundException('Notification not found');\n        }\n\n        if (notification.userId !== userId) {\n            throw new ForbiddenException('You can only mark your own notifications as delivered');\n        }\n\n        notification.deliveredAt = new Date();\n        notification.deliveredBy = userId;\n\n        if (dto.platform) {\n            notification.platform = dto.platform;\n        }\n\n        if (dto.device_info) {\n            notification.metadata = {\n                deviceInfo: dto.device_info,\n                ipAddress: dto.ip_address,\n                userAgent: dto.user_agent,\n            };\n        }\n\n        await this.notificationTemplateRepository.save(notification);\n\n        // TODO: Send delivery confirmation to user\n        // await this.emailService.send({\n        //     to: notification.userEmail,\n        //     from_name: 'LAW ORGANIZER',\n        //     template_name: 'delivery_confirmation',\n        //     template_data: {\n        //         user_name: notification.userFirstName || 'Користувач',\n        //         platform: dto.platform,\n        //         device_name: dto.device_info?.device_name || 'Невідомий пристрій',\n        //         notification_title: notification.title,\n        //     },\n        // });\n    }\n\n    /**\n     * Mark notification as failed\n     */\n    async markAsFailed(\n        tenantId: string,\n        notificationId: string,\n        userId: string,\n        error: {\n            error_code: string;\n            error_message: string;\n            platform?: 'web' | 'mobile' | 'desktop' | 'push' | 'in_app';\n            ip_address?: string;\n            user_agent?: string;\n            device_token?: string;\n            device_info?: Record<string, any>;\n        }\n    ): Promise<void> {\n        const notification = await this.notificationTemplateRepository.findOne({\n            where: {\n                id: notificationId,\n                tenantId,\n                deletedAt: null,\n            },\n        });\n\n        if (!notification) {\n            throw new NotFoundException('Notification not found');\n        }\n\n        if (notification.userId !== userId) {\n            throw new ForbiddenException('You can only mark your own notifications as failed');\n        }\n\n        notification.status = 'failed';\n        notification.error_code = error.error_code;\n        notification.error_message = error.error_message;\n\n        if (error.platform) {\n            notification.platform = error.platform;\n        }\n\n        notification.failedAt = new Date();\n        notification.failedBy = userId;\n        notification.metadata = {\n            ipAddress: error.ip_address,\n            userAgent: error.user_agent,\n            deviceInfo: error.device_info,\n            device_token: error.device_token,\n        };\n\n        await this.notificationTemplateRepository.save(notification);\n\n        // TODO: Send error notification to admin\n        // await this.notificationService.sendErrorNotification({\n        //     type: 'email',\n        //     priority: 'high',\n        //     title: 'Помилка повідомлення',\n        //     body: `Не вдалося відправити повідомлення для \"${notification.title}\"`,\n        // });\n    }\n\n    /**\n     * Get notification statistics\n     */\n    async getStatistics(tenantId: string): Promise<{\n        total: number;\n        byType: Record<string, number>;\n        byStatus: Record<string, number>;\n        byPlatform: Record<string, number>;\n        unread_count: number;\n    }> {\n        const [total] = await this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .select('COUNT(*)')\n            .where('notification.tenant_id = :tenantId AND notification.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const [byType] = await this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .select('notification.type', 'COUNT(*) as count')\n            .where('notification.tenant_id = :tenantId AND notification.deletedAt IS NULL', { tenantId })\n            .groupBy('notification.type')\n            .getRawMany();\n\n        const [byStatus] = await this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .select('notification.status', 'COUNT(*) as count')\n            .where('notification.tenant_id = :tenantId AND notification.deletedAt IS NULL', { tenantId })\n            .groupBy('notification.status')\n            .getRawMany();\n\n        const [byPlatform] = await this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .select('notification.platform', 'COUNT(*) as count')\n            .where('notification.tenant_id = :tenantId AND notification.deletedAt IS NULL', { tenantId })\n            .groupBy('notification.platform')\n            .getRawMany();\n\n        const [unreadCount] = await this.notificationTemplateRepository\n            .createQueryBuilder('notification')\n            .select('COUNT(*) as count')\n            .where('notification.tenant_id = :tenantId AND notification.deletedAt IS NULL AND notification.readAt IS NULL', { tenantId })\n            .getRawMany();\n\n        return {\n            total: parseInt(total[0].count),\n            byType: byType.reduce((acc, row) => {\n                acc[row.type] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            byStatus: byStatus.reduce((acc, row) => {\n                acc[row.status] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            byPlatform: byPlatform.reduce((acc, row) => {\n                acc[row.platform] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            unread_count: parseInt(unreadCount[0].count),\n        };\n    }\n}\n"],"names":["NotificationService","create","tenantId","userId","dto","notification","type","title","body","status","priority","data","createdNotification","sendEmailNotification","sendSmsNotification","sendPushNotification","sendInAppNotification","notificationTemplateRepository","save","queueNotification","getUserNotifications","filters","query","createQueryBuilder","where","andWhere","platform","orderBy","page","limit","skip","take","leftJoinAndSelect","total","getManyAndCount","markAsRead","notificationId","findOne","id","deletedAt","NotFoundException","ForbiddenException","readAt","Date","markAllAsRead","beforeDate","afterDate","batchSize","batch_size","markedCount","notifications","getMany","length","update","map","n","updatedBy","delete","deleteAll","result","tenant_id","user_id","deleted_at","updated_by","affected","getPreferences","user","userService","findById","email_enabled","sms_enabled","push_enabled","email_digest_enabled","sms_digest_enabled","push_digest_enabled","desktop_enabled","mobile_enabled","in_app_enabled","updatePreferences","preferences","getUnreadCount","count","read_at","options","emailService","send","to","userEmail","from_name","template_name","template_data","user_name","userFirstName","user_email","action","smsService","userPhone","message","code","verification_code","case_id","caseId","event_id","eventId","pushService","deviceId","inAppService","notification_type","notificationQueue","add","jobName","attempts","backoff","delay","markAsDelivered","deliveredAt","deliveredBy","device_info","metadata","deviceInfo","ipAddress","ip_address","userAgent","user_agent","markAsFailed","error","error_code","error_message","failedAt","failedBy","device_token","getStatistics","select","getRawMany","byType","groupBy","byStatus","byPlatform","unreadCount","parseInt","reduce","acc","row","unread_count"],"mappings":"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"}