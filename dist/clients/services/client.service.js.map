{"version":3,"sources":["../../../src/clients/services/client.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Client } from '../../database/entities/Client.entity';\nimport { CreateClientDto, UpdateClientDto, ClientFiltersDto } from '../dto/client.dto';\nimport { validateEdrpou, validateTaxNumber, detectSqlInjection } from '../../common/utils/validation.util';\n\n/**\n * Client Service\n */\n@Injectable()\nexport class ClientService {\n    constructor(\n        @InjectRepository(Client)\n        private readonly clientRepository: Repository<Client>,\n    ) {}\n\n    /**\n     * Get all clients with filters\n     */\n    async findAll(\n        tenantId: string,\n        filters: ClientFiltersDto = {}\n    ): Promise<{ data: Client[]; total: number; page: number; limit: number }> {\n        const query = this.clientRepository\n            .createQueryBuilder('client')\n            .where('client.tenantId = :tenantId AND client.deletedAt IS NULL', { tenantId });\n\n        // Search (name, email, phone)\n        if (filters.search) {\n            // Check for SQL injection\n            if (detectSqlInjection(filters.search)) {\n                throw new ForbiddenException('Invalid search query');\n            }\n\n            query.andWhere(\n                '(client.firstName ILIKE :search OR ' +\n                'client.lastName ILIKE :search OR ' +\n                'client.email ILIKE :search OR ' +\n                'client.phone ILIKE :search OR ' +\n                'client.companyName ILIKE :search)',\n                { search: `%${filters.search}%` }\n            );\n        }\n\n        // Filter by type\n        if (filters.type) {\n            query.andWhere('client.type = :type', { type: filters.type });\n        }\n\n        // Filter by status\n        if (filters.status) {\n            query.andWhere('client.status = :status', { status: filters.status });\n        }\n\n        // Filter by assigned user\n        if (filters.assignedUserId) {\n            query.andWhere('client.assignedUserId = :assignedUserId', {\n                assignedUserId: filters.assignedUserId,\n            });\n        }\n\n        // Filter by city\n        if (filters.city) {\n            query.andWhere('client.city = :city', { city: filters.city });\n        }\n\n        // Filter by region\n        if (filters.region) {\n            query.andWhere('client.region = :region', { region: filters.region });\n        }\n\n        // Filter by date range\n        if (filters.createdAtFrom) {\n            query.andWhere('client.createdAt >= :createdAtFrom', {\n                createdAtFrom: new Date(filters.createdAtFrom),\n            });\n        }\n\n        if (filters.createdAtTo) {\n            query.andWhere('client.createdAt <= :createdAtTo', {\n                createdAtTo: new Date(filters.createdAtTo),\n            });\n        }\n\n        // Sorting\n        const sortBy = filters.sortBy || 'createdAt';\n        const sortOrder = filters.sortOrder || 'DESC';\n        query.orderBy(`client.${sortBy}`, sortOrder);\n\n        // Pagination\n        const page = filters.page || 1;\n        const limit = filters.limit || 20;\n        const skip = (page - 1) * limit;\n\n        query.skip(skip).take(limit);\n\n        // Include relations\n        query.leftJoinAndSelect('client.assignedUser', 'assignedUser');\n\n        const [data, total] = await query.getManyAndCount();\n\n        return {\n            data,\n            total,\n            page,\n            limit,\n        };\n    }\n\n    /**\n     * Get client by ID\n     */\n    async findById(tenantId: string, id: string): Promise<Client> {\n        const client = await this.clientRepository.findOne({\n            where: {\n                id,\n                tenantId,\n                deletedAt: null,\n            },\n            relations: ['assignedUser', 'cases'],\n        });\n\n        if (!client) {\n            throw new NotFoundException('Клієнта не знайдено');\n        }\n\n        return client;\n    }\n\n    /**\n     * Create new client\n     */\n    async create(tenantId: string, userId: string, dto: CreateClientDto): Promise<Client> {\n        // Validate EDRPOU if provided\n        if (dto.edrpou && !validateEdrpou(dto.edrpou)) {\n            throw new ForbiddenException('Невірний формат ЄДРПОУ');\n        }\n\n        // Validate INN if provided\n        if (dto.inn && !validateTaxNumber(dto.inn)) {\n            throw new ForbiddenException('Невірний формат ІПН');\n        }\n\n        const client = this.clientRepository.create({\n            tenantId,\n            ...dto,\n            createdBy: userId,\n            updatedBy: userId,\n        });\n\n        return this.clientRepository.save(client);\n    }\n\n    /**\n     * Update existing client\n     */\n    async update(\n        tenantId: string,\n        id: string,\n        userId: string,\n        dto: UpdateClientDto\n    ): Promise<Client> {\n        const client = await this.findById(tenantId, id);\n\n        // Validate EDRPOU if provided\n        if (dto.edrpou && !validateEdrpou(dto.edrpou)) {\n            throw new ForbiddenException('Невірний формат ЄДРПОУ');\n        }\n\n        // Validate INN if provided\n        if (dto.inn && !validateTaxNumber(dto.inn)) {\n            throw new ForbiddenException('Невірний формат ІПН');\n        }\n\n        Object.assign(client, dto, {\n            updatedBy: userId,\n        });\n\n        return this.clientRepository.save(client);\n    }\n\n    /**\n     * Delete client (soft delete)\n     */\n    async delete(tenantId: string, id: string, userId: string): Promise<void> {\n        const client = await this.findById(tenantId, id);\n\n        // Update instead of actual delete\n        await this.clientRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: new Date(),\n                updatedBy: userId,\n            }\n        );\n    }\n\n    /**\n     * Restore deleted client\n     */\n    async restore(tenantId: string, id: string, userId: string): Promise<Client> {\n        await this.clientRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: null,\n                updatedBy: userId,\n            }\n        );\n\n        return this.findById(tenantId, id);\n    }\n\n    /**\n     * Bulk import clients\n     */\n    async bulkImport(\n        tenantId: string,\n        userId: string,\n        dtos: CreateClientDto[]\n    ): Promise<{ success: number; failed: number; errors: any[] }> {\n        const results = {\n            success: 0,\n            failed: 0,\n            errors: [] as any[],\n        };\n\n        for (const dto of dtos) {\n            try {\n                await this.create(tenantId, userId, dto);\n                results.success++;\n            } catch (error) {\n                results.failed++;\n                results.errors.push({\n                    client: dto,\n                    error: error.message,\n                });\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Get client statistics\n     */\n    async getStatistics(tenantId: string): Promise<{\n        total: number;\n        active: number;\n        inactive: number;\n        individuals: number;\n        legalEntities: number;\n    }> {\n        const [total] = await this.clientRepository\n            .createQueryBuilder('client')\n            .select('COUNT(*)')\n            .where('client.tenantId = :tenantId AND client.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const [active] = await this.clientRepository\n            .createQueryBuilder('client')\n            .select('COUNT(*)')\n            .where('client.tenantId = :tenantId AND client.status = :status AND client.deletedAt IS NULL', {\n                tenantId,\n                status: 'active',\n            })\n            .getRawMany();\n\n        const [inactive] = await this.clientRepository\n            .createQueryBuilder('client')\n            .select('COUNT(*)')\n            .where('client.tenantId = :tenantId AND client.status = :status AND client.deletedAt IS NULL', {\n                tenantId,\n                status: 'inactive',\n            })\n            .getRawMany();\n\n        const [individuals] = await this.clientRepository\n            .createQueryBuilder('client')\n            .select('COUNT(*)')\n            .where('client.tenantId = :tenantId AND client.type = :type AND client.deletedAt IS NULL', {\n                tenantId,\n                type: 'individual',\n            })\n            .getRawMany();\n\n        const [legalEntities] = await this.clientRepository\n            .createQueryBuilder('client')\n            .select('COUNT(*)')\n            .where('client.tenantId = :tenantId AND client.type = :type AND client.deletedAt IS NULL', {\n                tenantId,\n                type: 'legal_entity',\n            })\n            .getRawMany();\n\n        return {\n            total: parseInt(total[0].count),\n            active: parseInt(active[0].count),\n            inactive: parseInt(inactive[0].count),\n            individuals: parseInt(individuals[0].count),\n            legalEntities: parseInt(legalEntities[0].count),\n        };\n    }\n}\n"],"names":["ClientService","findAll","tenantId","filters","query","clientRepository","createQueryBuilder","where","search","detectSqlInjection","ForbiddenException","andWhere","type","status","assignedUserId","city","region","createdAtFrom","Date","createdAtTo","sortBy","sortOrder","orderBy","page","limit","skip","take","leftJoinAndSelect","data","total","getManyAndCount","findById","id","client","findOne","deletedAt","relations","NotFoundException","create","userId","dto","edrpou","validateEdrpou","inn","validateTaxNumber","createdBy","updatedBy","save","update","Object","assign","delete","restore","bulkImport","dtos","results","success","failed","errors","error","push","message","getStatistics","select","getRawMany","active","inactive","individuals","legalEntities","parseInt","count"],"mappings":"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"}