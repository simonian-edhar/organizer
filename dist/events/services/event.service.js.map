{"version":3,"sources":["../../../src/events/services/event.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, Between, In } from 'typeorm';\nimport { Event } from '../../database/entities/Event.entity';\nimport { CreateEventDto, UpdateEventDto, EventFiltersDto } from '../dto/event.dto';\nimport { validateEmail, detectSqlInjection } from '../../common/utils/validation.util';\n\n/**\n * Event Service\n */\n@Injectable()\nexport class EventService {\n    constructor(\n        @InjectRepository(Event)\n        private readonly eventRepository: Repository<Event>,\n    ) {}\n\n    /**\n     * Get all events with filters\n     */\n    async findAll(\n        tenantId: string,\n        filters: EventFiltersDto = {}\n    ): Promise<{ data: Event[]; total: number; page: number; limit: number }> {\n        const query = this.eventRepository\n            .createQueryBuilder('event')\n            .where('event.tenantId = :tenantId AND event.deletedAt IS NULL', { tenantId });\n\n        // Filter by case\n        if (filters.caseId) {\n            query.andWhere('event.caseId = :caseId', { caseId: filters.caseId });\n        }\n\n        // Filter by type\n        if (filters.type) {\n            query.andWhere('event.type = :type', { type: filters.type });\n        }\n\n        // Filter by status\n        if (filters.status) {\n            query.andWhere('event.status = :status', { status: filters.status });\n        }\n\n        // Filter by date range\n        if (filters.eventDateFrom && filters.eventDateTo) {\n            query.andWhere('event.eventDate BETWEEN :eventDateFrom AND :eventDateTo', {\n                eventDateFrom: new Date(filters.eventDateFrom),\n                eventDateTo: new Date(filters.eventDateTo),\n            });\n        } else if (filters.eventDateFrom) {\n            query.andWhere('event.eventDate >= :eventDateFrom', {\n                eventDateFrom: new Date(filters.eventDateFrom),\n            });\n        } else if (filters.eventDateTo) {\n            query.andWhere('event.eventDate <= :eventDateTo', {\n                eventDateTo: new Date(filters.eventDateTo),\n            });\n        }\n\n        // Search\n        if (filters.search) {\n            if (detectSqlInjection(filters.search)) {\n                throw new ForbiddenException('Invalid search query');\n            }\n\n            query.andWhere(\n                '(event.title ILIKE :search OR ' +\n                'event.description ILIKE :search OR ' +\n                'event.location ILIKE :search)',\n                { search: `%${filters.search}%` }\n            );\n        }\n\n        // Sorting\n        const sortBy = filters.sortBy || 'eventDate';\n        const sortOrder = filters.sortOrder || 'ASC';\n        query.orderBy(`event.${sortBy}`, sortOrder);\n\n        // Pagination\n        const page = filters.page || 1;\n        const limit = filters.limit || 20;\n        const skip = (page - 1) * limit;\n\n        query.skip(skip).take(limit);\n\n        // Include relations\n        query.leftJoinAndSelect('event.case', 'case');\n        query.leftJoinAndSelect('event.createdByUser', 'createdByUser');\n\n        const [data, total] = await query.getManyAndCount();\n\n        return {\n            data,\n            total,\n            page,\n            limit,\n        };\n    }\n\n    /**\n     * Get event by ID\n     */\n    async findById(tenantId: string, id: string): Promise<Event> {\n        const event = await this.eventRepository.findOne({\n            where: {\n                id,\n                tenantId,\n                deletedAt: null,\n            },\n            relations: ['case', 'createdByUser'],\n        });\n\n        if (!event) {\n            throw new NotFoundException('Подію не знайдено');\n        }\n\n        return event;\n    }\n\n    /**\n     * Create new event\n     */\n    async create(tenantId: string, userId: string, dto: CreateEventDto): Promise<Event> {\n        const event = this.eventRepository.create({\n            tenantId,\n            ...dto,\n            status: 'scheduled',\n            reminderSent: false,\n            reminderDaysBefore: dto.reminderDaysBefore || 1,\n            createdBy: userId,\n            updatedBy: userId,\n        });\n\n        const savedEvent = await this.eventRepository.save(event);\n\n        // TODO: Schedule reminders (cron job or Bull queue)\n        await this.scheduleReminders(savedEvent);\n\n        return savedEvent;\n    }\n\n    /**\n     * Update event\n     */\n    async update(\n        tenantId: string,\n        id: string,\n        userId: string,\n        dto: UpdateEventDto\n    ): Promise<Event> {\n        const event = await this.findById(tenantId, id);\n\n        Object.assign(event, dto, {\n            updatedBy: userId,\n        });\n\n        return this.eventRepository.save(event);\n    }\n\n    /**\n     * Delete event (soft delete)\n     */\n    async delete(tenantId: string, id: string, userId: string): Promise<void> {\n        const event = await this.findById(tenantId, id);\n\n        await this.eventRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: new Date(),\n                updatedBy: userId,\n            }\n        );\n    }\n\n    /**\n     * Get upcoming events\n     */\n    async getUpcoming(tenantId: string, days: number = 30): Promise<Event[]> {\n        const now = new Date();\n        const futureDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);\n\n        return this.eventRepository.find({\n            where: {\n                tenantId,\n                eventDate: Between(now, futureDate),\n                status: In(['scheduled', 'in_progress']),\n                deletedAt: null,\n            },\n            order: {\n                eventDate: 'ASC',\n                eventTime: 'ASC',\n            },\n            relations: ['case'],\n        });\n    }\n\n    /**\n     * Get calendar events (for integration)\n     */\n    async getCalendarEvents(\n        tenantId: string,\n        startDate: Date,\n        endDate: Date\n    ): Promise<Event[]> {\n        return this.eventRepository.find({\n            where: {\n                tenantId,\n                eventDate: Between(startDate, endDate),\n                deletedAt: null,\n            },\n            order: {\n                eventDate: 'ASC',\n                eventTime: 'ASC',\n            },\n            relations: ['case'],\n        });\n    }\n\n    /**\n     * Schedule reminders\n     */\n    private async scheduleReminders(event: Event): Promise<void> {\n        // TODO: Implement with Bull queue or BullMQ\n        // This would create jobs to send reminders before the event\n\n        // Example:\n        // await this.remindersQueue.add(\n        //     'send-event-reminder',\n        //     { eventId: event.id, tenantId: event.tenantId },\n        //     {\n        //         delay: (event.eventDate.getTime() - Date.now()) - (event.reminderDaysBefore * 24 * 60 * 60 * 1000),\n        //     }\n        // );\n    }\n\n    /**\n     * Get event statistics\n     */\n    async getStatistics(tenantId: string): Promise<{\n        total: number;\n        byType: Record<string, number>;\n        byStatus: Record<string, number>;\n        upcoming: number;\n    overdue: number;\n    }> {\n        const now = new Date();\n\n        const [total] = await this.eventRepository\n            .createQueryBuilder('event')\n            .select('COUNT(*)')\n            .where('event.tenantId = :tenantId AND event.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const [upcoming] = await this.eventRepository\n            .createQueryBuilder('event')\n            .select('COUNT(*)')\n            .where(\n                'event.tenantId = :tenantId AND event.eventDate >= :now AND event.status IN (:statuses) AND event.deletedAt IS NULL',\n                { tenantId, now, statuses: ['scheduled', 'in_progress'] }\n            )\n            .getRawMany();\n\n        const [overdue] = await this.eventRepository\n            .createQueryBuilder('event')\n            .select('COUNT(*)')\n            .where(\n                'event.tenantId = :tenantId AND event.eventDate < :now AND event.status = :status AND event.deletedAt IS NULL',\n                { tenantId, now, status: 'scheduled' }\n            )\n            .getRawMany();\n\n        const byType = await this.eventRepository\n            .createQueryBuilder('event')\n            .select('event.type', 'COUNT(*) as count')\n            .where('event.tenantId = :tenantId AND event.deletedAt IS NULL', { tenantId })\n            .groupBy('event.type')\n            .getRawMany();\n\n        const byStatus = await this.eventRepository\n            .createQueryBuilder('event')\n            .select('event.status', 'COUNT(*) as count')\n            .where('event.tenantId = :tenantId AND event.deletedAt IS NULL', { tenantId })\n            .groupBy('event.status')\n            .getRawMany();\n\n        return {\n            total: parseInt(total[0].count),\n            upcoming: parseInt(upcoming[0].count),\n            overdue: parseInt(overdue[0].count),\n            byType: byType.reduce((acc, row) => {\n                acc[row.type] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            byStatus: byStatus.reduce((acc, row) => {\n                acc[row.status] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n        };\n    }\n}\n"],"names":["EventService","findAll","tenantId","filters","query","eventRepository","createQueryBuilder","where","caseId","andWhere","type","status","eventDateFrom","eventDateTo","Date","search","detectSqlInjection","ForbiddenException","sortBy","sortOrder","orderBy","page","limit","skip","take","leftJoinAndSelect","data","total","getManyAndCount","findById","id","event","findOne","deletedAt","relations","NotFoundException","create","userId","dto","reminderSent","reminderDaysBefore","createdBy","updatedBy","savedEvent","save","scheduleReminders","update","Object","assign","delete","getUpcoming","days","now","futureDate","getTime","find","eventDate","Between","In","order","eventTime","getCalendarEvents","startDate","endDate","getStatistics","select","getRawMany","upcoming","statuses","overdue","byType","groupBy","byStatus","parseInt","count","reduce","acc","row"],"mappings":"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"}