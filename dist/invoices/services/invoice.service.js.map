{"version":3,"sources":["../../../src/invoices/services/invoice.service.ts"],"sourcesContent":["import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { PricelistController } from '../controllers/pricelist.controller';\nimport { PricelistService } from '../services/pricelist.service';\nimport { PricelistService } from '../services/pricelist.service';\nimport { Invoice } from '../../database/entities/Invoice.entity';\nimport {\n    CreateInvoiceDto,\n    UpdateInvoiceDto,\n    InvoiceFiltersDto,\n    GenerateInvoicePdfDto,\n} from '../dto/invoice.dto';\n\n/**\n * Invoice Service\n */\n@Injectable()\nexport class InvoiceService {\n    constructor(\n        @InjectRepository(Invoice)\n        private readonly invoiceRepository: Repository<Invoice>,\n    ) {}\n\n    /**\n     * Get all invoices with filters\n     */\n    async findAll(\n        tenantId: string,\n        filters: InvoiceFiltersDto = {}\n    ): Promise<{ data: Invoice[]; total: number; page: number; limit: number }> {\n        const query = this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .where('invoice.tenantId = :tenantId AND invoice.deletedAt IS NULL', { tenantId });\n\n        // Filter by client\n        if (filters.clientId) {\n            query.andWhere('invoice.clientId = :clientId', { clientId: filters.clientId });\n        }\n\n        // Filter by status\n        if (filters.status) {\n            query.andWhere('invoice.status = :status', { status: filters.status });\n        }\n\n        // Filter by date range\n        if (filters.invoiceDateFrom && filters.invoiceDateTo) {\n            query.andWhere('invoice.invoiceDate BETWEEN :invoiceDateFrom AND :invoiceDateTo', {\n                invoiceDateFrom: new Date(filters.invoiceDateFrom),\n                invoiceDateTo: new Date(filters.invoiceDateTo),\n            });\n        } else if (filters.invoiceDateFrom) {\n            query.andWhere('invoice.invoiceDate >= :invoiceDateFrom', {\n                invoiceDateFrom: new Date(filters.invoiceDateFrom),\n            });\n        } else if (filters.invoiceDateTo) {\n            query.andWhere('invoice.invoiceDate <= :invoiceDateTo', {\n                invoiceDateTo: new Date(filters.invoiceDateTo),\n            });\n        }\n\n        // Search\n        if (filters.search) {\n            query.andWhere(\n                '(invoice.invoiceNumber ILIKE :search OR ' +\n                'invoice.description ILIKE :search)',\n                { search: `%${filters.search}%` }\n            );\n        }\n\n        // Sorting\n        const sortBy = filters.sortBy || 'invoiceDate';\n        const sortOrder = filters.sortOrder || 'DESC';\n        query.orderBy(`invoice.${sortBy}`, sortOrder);\n\n        // Pagination\n        const page = filters.page || 1;\n        const limit = filters.limit || 20;\n        const skip = (page - 1) * limit;\n\n        query.skip(skip).take(limit);\n\n        const [data, total] = await query.getManyAndCount();\n\n        return {\n            data,\n            total,\n            page,\n            limit,\n        };\n    }\n\n    /**\n     * Get invoice by ID\n     */\n    async findById(tenantId: string, id: string): Promise<Invoice> {\n        const invoice = await this.invoiceRepository.findOne({\n            where: {\n                id,\n                tenantId,\n                deletedAt: null,\n            },\n            relations: ['items'],\n        });\n\n        if (!invoice) {\n            throw new NotFoundException('Рахунок не знайдено');\n        }\n\n        return invoice;\n    }\n\n    /**\n     * Create new invoice\n     */\n    async create(\n        tenantId: string,\n        userId: string,\n        dto: CreateInvoiceDto\n    ): Promise<Invoice> {\n        // Generate invoice number\n        const invoiceNumber = await this.generateInvoiceNumber(tenantId);\n\n        const invoice = this.invoiceRepository.create({\n            tenantId,\n            ...dto,\n            invoiceNumber,\n            status: 'draft',\n            createdBy: userId,\n            updatedBy: userId,\n        });\n\n        return this.invoiceRepository.save(invoice);\n    }\n\n    /**\n     * Update invoice\n     */\n    async update(\n        tenantId: string,\n        id: string,\n        userId: string,\n        dto: UpdateInvoiceDto\n    ): Promise<Invoice> {\n        const invoice = await this.findById(tenantId, id);\n\n        Object.assign(invoice, dto, {\n            updatedBy: userId,\n        });\n\n        return this.invoiceRepository.save(invoice);\n    }\n\n    /**\n     * Delete invoice (soft delete)\n     */\n    async delete(tenantId: string, id: string, userId: string): Promise<void> {\n        const invoice = await this.findById(tenantId, id);\n\n        await this.invoiceRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: new Date(),\n                updatedBy: userId,\n                status: 'cancelled',\n            }\n        );\n    }\n\n    /**\n     * Send invoice\n     */\n    async send(tenantId: string, id: string, userId: string): Promise<Invoice> {\n        const invoice = await this.findById(tenantId, id);\n\n        // TODO: Send email/SMS to client\n        // TODO: Generate PDF\n        // TODO: Update status to 'sent'\n\n        invoice.status = 'sent';\n        invoice.updatedBy = userId;\n\n        return this.invoiceRepository.save(invoice);\n    }\n\n    /**\n     * Generate invoice PDF\n     */\n    async generatePdf(\n        tenantId: string,\n        id: string,\n        dto: GenerateInvoicePdfDto\n    ): Promise<{ pdfUrl: string; pdfGeneratedAt: Date }> {\n        const invoice = await this.findById(tenantId, id);\n\n        // TODO: Generate PDF using template service\n        // TODO: Store PDF in S3/MinIO\n        // TODO: Update invoice with pdfUrl and pdfGeneratedAt\n\n        const pdfUrl = `https://cdn.laworganizer.ua/invoices/${id}.pdf`;\n        const pdfGeneratedAt = new Date();\n\n        invoice.pdfUrl = pdfUrl;\n        invoice.pdfGeneratedAt = pdfGeneratedAt;\n        invoice.updatedBy = dto.userId;\n\n        await this.invoiceRepository.save(invoice);\n\n        return { pdfUrl, pdfGeneratedAt };\n    }\n\n    /**\n     * Record payment\n     */\n    async recordPayment(\n        tenantId: string,\n        id: string,\n        userId: string,\n        payment: {\n            amount: number;\n            method: 'cash' | 'card' | 'bank_transfer' | 'wayforpay';\n            reference?: string;\n        }\n    ): Promise<Invoice> {\n        const invoice = await this.findById(tenantId, id);\n\n        const paidAmount = invoice.paidAmount + payment.amount;\n        const isFullyPaid = paidAmount >= invoice.totalAmount;\n\n        invoice.paidAmount = paidAmount;\n        invoice.paymentMethod = payment.method;\n        invoice.paymentReference = payment.reference;\n        invoice.paidAt = new Date();\n        invoice.status = isFullyPaid ? 'paid' : 'partial';\n        invoice.updatedBy = userId;\n\n        return this.invoiceRepository.save(invoice);\n    }\n\n    /**\n     * Generate invoice number\n     */\n    private async generateInvoiceNumber(tenantId: string): Promise<string> {\n        const prefix = 'INV';\n        const date = new Date();\n        const year = date.getFullYear();\n        const month = String(date.getMonth() + 1).padStart(2, '0');\n\n        // Get latest invoice number for this month/year\n        const latest = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('invoice.invoiceNumber')\n            .where('invoice.tenantId = :tenantId AND invoice.invoiceNumber LIKE :pattern', {\n                tenantId,\n                pattern: `${prefix}-${year}-${month}-%`,\n            })\n            .orderBy('invoice.invoiceNumber', 'DESC')\n            .limit(1)\n            .getOne();\n\n        let number = 1;\n        if (latest) {\n            const parts = latest.invoiceNumber.split('-');\n            number = parseInt(parts[3]) + 1;\n        }\n\n        return `${prefix}-${year}-${month}-${String(number).padStart(4, '0')}`;\n    }\n\n    /**\n     * Get invoice statistics\n     */\n    async getStatistics(tenantId: string): Promise<{\n        total: number;\n        byStatus: Record<string, number>;\n        totalAmount: number;\n        paidAmount: number;\n        outstandingAmount: number;\n        overdueCount: number;\n    }> {\n        const now = new Date();\n\n        const [total] = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('COUNT(*)')\n            .where('invoice.tenantId = :tenantId AND invoice.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const [byStatus] = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('invoice.status', 'COUNT(*) as count')\n            .where('invoice.tenantId = :tenantId AND invoice.deletedAt IS NULL', { tenantId })\n            .groupBy('invoice.status')\n            .getRawMany();\n\n        const [totalAmount] = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('SUM(invoice.totalAmount)')\n            .where('invoice.tenantId = :tenantId AND invoice.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const [paidAmount] = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('SUM(invoice.paidAmount)')\n            .where('invoice.tenantId = :tenantId AND invoice.deletedAt IS NULL', { tenantId })\n            .getRawMany();\n\n        const outstandingAmount = (totalAmount[0].sum || 0) - (paidAmount[0].sum || 0);\n\n        const [overdueCount] = await this.invoiceRepository\n            .createQueryBuilder('invoice')\n            .select('COUNT(*)')\n            .where(\n                'invoice.tenantId = :tenantId AND ' +\n                'invoice.status != :paid AND ' +\n                'invoice.status != :cancelled AND ' +\n                'invoice.dueDate < :now AND ' +\n                'invoice.deletedAt IS NULL',\n                { tenantId, paid: 'paid', cancelled: now }\n            )\n            .getRawMany();\n\n        return {\n            total: parseInt(total[0].count),\n            totalAmount: totalAmount[0].sum || 0,\n            paidAmount: paidAmount[0].sum || 0,\n            outstandingAmount,\n            overdueCount: parseInt(overdueCount[0].count),\n            byStatus: byStatus.reduce((acc, row) => {\n                acc[row.status] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n        };\n    }\n}\n"],"names":["InvoiceService","findAll","tenantId","filters","query","invoiceRepository","createQueryBuilder","where","clientId","andWhere","status","invoiceDateFrom","invoiceDateTo","Date","search","sortBy","sortOrder","orderBy","page","limit","skip","take","data","total","getManyAndCount","findById","id","invoice","findOne","deletedAt","relations","NotFoundException","create","userId","dto","invoiceNumber","generateInvoiceNumber","createdBy","updatedBy","save","update","Object","assign","delete","send","generatePdf","pdfUrl","pdfGeneratedAt","recordPayment","payment","paidAmount","amount","isFullyPaid","totalAmount","paymentMethod","method","paymentReference","reference","paidAt","prefix","date","year","getFullYear","month","String","getMonth","padStart","latest","select","pattern","getOne","number","parts","split","parseInt","getStatistics","now","getRawMany","byStatus","groupBy","outstandingAmount","sum","overdueCount","paid","cancelled","count","reduce","acc","row"],"mappings":"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"}