{"version":3,"sources":["../../../../src/enterprise/performance/services/query-optimization.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, DataSource, QueryRunner } from 'typeorm';\nimport {\n    QueryOptimizationConfig,\n    SlowQueryLog,\n    QueryPlan,\n    IndexSuggestion,\n    DEFAULT_OPTIMIZATION_CONFIG,\n    OPTIMIZATION_PATTERNS,\n} from '../interfaces/query-optimization.interface';\n\n/**\n * Query Optimization Service\n * Analyzes and optimizes database queries\n */\n@Injectable()\nexport class QueryOptimizationService {\n    private readonly logger = new Logger(QueryOptimizationService.name);\n    private readonly config: QueryOptimizationConfig;\n    private slowQueryLogs: SlowQueryLog[] = [];\n    private readonly maxLogSize = 1000;\n\n    constructor(\n        private readonly dataSource: DataSource,\n        private readonly configService: ConfigService,\n    ) {\n        this.config = {\n            ...DEFAULT_OPTIMIZATION_CONFIG,\n            slowQueryThreshold: this.configService.get('SLOW_QUERY_THRESHOLD', 1000),\n            enableQueryLogging: this.configService.get('ENABLE_QUERY_LOGGING', true),\n        };\n\n        this.setupQueryLogger();\n    }\n\n    /**\n     * Setup TypeORM query logger\n     */\n    private setupQueryLogger(): void {\n        this.dataSource.setOptions({\n            logging: this.config.enableQueryLogging,\n            logger: {\n                logQuery: (query: string, parameters?: any[]) => {\n                    // Query logging handled by middleware\n                },\n                logQueryError: (error: string, query: string, parameters?: any[]) => {\n                    this.logger.error(`Query Error: ${error}\\nQuery: ${query}`);\n                },\n                logQuerySlow: (time: number, query: string, parameters?: any[]) => {\n                    this.logSlowQuery(query, time, parameters);\n                },\n                logSchemaBuild: (message: string) => {\n                    this.logger.log(message);\n                },\n                logMigration: (message: string) => {\n                    this.logger.log(message);\n                },\n                log: (level: 'log' | 'info' | 'warn', message: any) => {\n                    switch (level) {\n                        case 'log':\n                        case 'info':\n                            this.logger.log(message);\n                            break;\n                        case 'warn':\n                            this.logger.warn(message);\n                            break;\n                    }\n                },\n            },\n        });\n    }\n\n    /**\n     * Log slow query\n     */\n    private logSlowQuery(query: string, duration: number, params?: any[], tenantId?: string): void {\n        const logEntry: SlowQueryLog = {\n            query,\n            duration,\n            timestamp: new Date(),\n            tenantId,\n            params: params,\n        };\n\n        this.slowQueryLogs.push(logEntry);\n\n        // Trim logs if exceeding max size\n        if (this.slowQueryLogs.length > this.maxLogSize) {\n            this.slowQueryLogs = this.slowQueryLogs.slice(-this.maxLogSize);\n        }\n\n        this.logger.warn(`Slow query (${duration}ms): ${query.substring(0, 200)}...`);\n    }\n\n    /**\n     * Get slow query logs\n     */\n    getSlowQueries(limit: number = 100): SlowQueryLog[] {\n        return this.slowQueryLogs\n            .sort((a, b) => b.duration - a.duration)\n            .slice(0, limit);\n    }\n\n    /**\n     * Analyze query execution plan\n     */\n    async analyzeQueryPlan(query: string, params?: any[]): Promise<QueryPlan> {\n        const queryRunner = this.dataSource.createQueryRunner();\n\n        try {\n            await queryRunner.connect();\n\n            // Get execution plan\n            const explainQuery = `EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON) ${query}`;\n            const result = await queryRunner.query(explainQuery, params);\n\n            const plan = result[0];\n            const planData = plan['QUERY PLAN']?.[0] || plan[0]?.['QUERY PLAN'] || plan;\n\n            const suggestions = this.generatePlanSuggestions(planData);\n\n            return {\n                plan: JSON.stringify(planData, null, 2),\n                executionTime: planData['Execution Time'] || 0,\n                totalCost: planData['Total Cost'] || 0,\n                indexesUsed: this.extractIndexes(planData),\n                suggestions,\n            };\n        } finally {\n            await queryRunner.release();\n        }\n    }\n\n    /**\n     * Generate suggestions from query plan\n     */\n    private generatePlanSuggestions(planData: any): string[] {\n        const suggestions: string[] = [];\n\n        const planStr = JSON.stringify(planData);\n\n        // Check for sequential scans\n        if (planStr.includes('Seq Scan')) {\n            suggestions.push('Consider adding an index to avoid sequential scan');\n        }\n\n        // Check for nested loops with high row count\n        if (planStr.includes('Nested Loop')) {\n            const nestedLoops = (planStr.match(/Nested Loop/g) || []).length;\n            if (nestedLoops > 2) {\n                suggestions.push('Multiple nested loops detected - consider restructuring query or adding indexes');\n            }\n        }\n\n        // Check for sort operations\n        if (planStr.includes('Sort') && planStr.includes('Sort Method: external merge')) {\n            suggestions.push('External merge sort detected - consider increasing work_mem or adding index for ORDER BY');\n        }\n\n        // Check for hash joins\n        if (planStr.includes('Hash Join') && planStr.includes('Hash Cond')) {\n            // Usually good, but check if hash is spilling to disk\n            if (planStr.includes('Hash Buckets')) {\n                suggestions.push('Hash join detected - ensure join columns are indexed');\n            }\n        }\n\n        return suggestions;\n    }\n\n    /**\n     * Extract indexes used from query plan\n     */\n    private extractIndexes(planData: any): string[] {\n        const indexes: string[] = [];\n        const planStr = JSON.stringify(planData);\n\n        // Look for index scan patterns\n        const indexMatches = planStr.matchAll(/Index Scan using (\\w+)/g);\n        for (const match of indexMatches) {\n            indexes.push(match[1]);\n        }\n\n        const bitmapMatches = planStr.matchAll(/Bitmap Index Scan on (\\w+)/g);\n        for (const match of bitmapMatches) {\n            indexes.push(match[1]);\n        }\n\n        return [...new Set(indexes)];\n    }\n\n    /**\n     * Get index suggestions for table\n     */\n    async getIndexSuggestions(tableName: string): Promise<IndexSuggestion[]> {\n        const queryRunner = this.dataSource.createQueryRunner();\n        const suggestions: IndexSuggestion[] = [];\n\n        try {\n            await queryRunner.connect();\n\n            // Get table statistics\n            const statsQuery = `\n                SELECT\n                    schemaname,\n                    relname as table_name,\n                    n_live_tup as row_count,\n                    n_dead_tup as dead_rows,\n                    last_vacuum,\n                    last_autovacuum,\n                    last_analyze,\n                    last_autoanalyze\n                FROM pg_stat_user_tables\n                WHERE relname = $1\n            `;\n\n            const stats = await queryRunner.query(statsQuery, [tableName]);\n\n            if (stats.length === 0) {\n                return [];\n            }\n\n            const tableStats = stats[0];\n\n            // Check for high dead row ratio\n            if (tableStats.dead_rows > 0 && tableStats.row_count > 0) {\n                const deadRatio = tableStats.dead_rows / tableStats.row_count;\n                if (deadRatio > 0.2) {\n                    suggestions.push({\n                        table: tableName,\n                        columns: [],\n                        reason: `High dead row ratio (${(deadRatio * 100).toFixed(1)}%) - consider running VACUUM`,\n                        estimatedImprovement: 'Improved query performance and space reclamation',\n                    });\n                }\n            }\n\n            // Get missing index suggestions from pg_stat_user_indexes\n            const indexQuery = `\n                SELECT\n                    indexrelname as index_name,\n                    idx_scan as index_scans,\n                    idx_tup_read as tuples_read,\n                    idx_tup_fetch as tuples_fetched\n                FROM pg_stat_user_indexes\n                JOIN pg_index USING (indexrelid)\n                WHERE relname = $1\n                AND NOT indisunique\n                ORDER BY idx_scan ASC\n            `;\n\n            const unusedIndexes = await queryRunner.query(indexQuery, [tableName]);\n\n            for (const idx of unusedIndexes.slice(0, 3)) {\n                if (idx.index_scans === 0) {\n                    suggestions.push({\n                        table: tableName,\n                        columns: [idx.index_name],\n                        reason: `Index ${idx.index_name} has never been used - consider removing`,\n                        estimatedImprovement: 'Reduced write overhead and storage',\n                    });\n                }\n            }\n\n            // Get frequently queried columns from pg_stats\n            const columnStatsQuery = `\n                SELECT\n                    column_name,\n                    n_distinct,\n                    null_frac\n                FROM pg_stats\n                WHERE tablename = $1\n                ORDER BY n_distinct DESC\n            `;\n\n            const columnStats = await queryRunner.query(columnStatsQuery, [tableName]);\n\n            for (const col of columnStats.slice(0, 3)) {\n                if (col.n_distinct > 0.1 && col.n_distinct < 1 && col.null_frac < 0.1) {\n                    suggestions.push({\n                        table: tableName,\n                        columns: [col.column_name],\n                        reason: `Column ${col.column_name} has good selectivity - consider indexing if frequently used in WHERE`,\n                        estimatedImprovement: 'Potential 10x-100x query speedup',\n                    });\n                }\n            }\n\n            return suggestions;\n        } finally {\n            await queryRunner.release();\n        }\n    }\n\n    /**\n     * Get database statistics\n     */\n    async getDatabaseStats(): Promise<{\n        tableCount: number;\n        indexCount: number;\n        totalSize: string;\n        connectionCount: number;\n        cacheHitRatio: number;\n    }> {\n        const queryRunner = this.dataSource.createQueryRunner();\n\n        try {\n            await queryRunner.connect();\n\n            const tableCountQuery = `SELECT count(*) FROM information_schema.tables WHERE table_schema = 'public'`;\n            const indexCountQuery = `SELECT count(*) FROM pg_indexes WHERE schemaname = 'public'`;\n            const totalSizeQuery = `SELECT pg_size_pretty(pg_database_size(current_database()))`;\n            const connectionCountQuery = `SELECT count(*) FROM pg_stat_activity WHERE datname = current_database()`;\n            const cacheHitQuery = `\n                SELECT\n                    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio\n                FROM pg_statio_user_tables\n            `;\n\n            const [tables, indexes, size, connections, cache] = await Promise.all([\n                queryRunner.query(tableCountQuery),\n                queryRunner.query(indexCountQuery),\n                queryRunner.query(totalSizeQuery),\n                queryRunner.query(connectionCountQuery),\n                queryRunner.query(cacheHitQuery),\n            ]);\n\n            return {\n                tableCount: parseInt(tables[0].count),\n                indexCount: parseInt(indexes[0].count),\n                totalSize: size[0].pg_size_pretty,\n                connectionCount: parseInt(connections[0].count),\n                cacheHitRatio: parseFloat(cache[0]?.ratio || '0'),\n            };\n        } finally {\n            await queryRunner.release();\n        }\n    }\n\n    /**\n     * Run VACUUM ANALYZE on table\n     */\n    async vacuumAnalyze(tableName: string): Promise<void> {\n        const queryRunner = this.dataSource.createQueryRunner();\n\n        try {\n            await queryRunner.connect();\n            await queryRunner.query(`VACUUM ANALYZE \"${tableName}\"`);\n            this.logger.log(`VACUUM ANALYZE completed for table: ${tableName}`);\n        } finally {\n            await queryRunner.release();\n        }\n    }\n\n    /**\n     * Clear slow query logs\n     */\n    clearSlowQueryLogs(): void {\n        this.slowQueryLogs = [];\n    }\n\n    /**\n     * Get query performance summary\n     */\n    getPerformanceSummary(): {\n        totalSlowQueries: number;\n        averageDuration: number;\n        slowestQuery: SlowQueryLog | null;\n    } {\n        if (this.slowQueryLogs.length === 0) {\n            return {\n                totalSlowQueries: 0,\n                averageDuration: 0,\n                slowestQuery: null,\n            };\n        }\n\n        const totalDuration = this.slowQueryLogs.reduce((sum, log) => sum + log.duration, 0);\n        const slowest = this.slowQueryLogs.reduce((prev, current) =>\n            current.duration > prev.duration ? current : prev\n        );\n\n        return {\n            totalSlowQueries: this.slowQueryLogs.length,\n            averageDuration: totalDuration / this.slowQueryLogs.length,\n            slowestQuery: slowest,\n        };\n    }\n}\n"],"names":["QueryOptimizationService","setupQueryLogger","dataSource","setOptions","logging","config","enableQueryLogging","logger","logQuery","query","parameters","logQueryError","error","logQuerySlow","time","logSlowQuery","logSchemaBuild","message","log","logMigration","level","warn","duration","params","tenantId","logEntry","timestamp","Date","slowQueryLogs","push","length","maxLogSize","slice","substring","getSlowQueries","limit","sort","a","b","analyzeQueryPlan","queryRunner","createQueryRunner","connect","explainQuery","result","plan","planData","suggestions","generatePlanSuggestions","JSON","stringify","executionTime","totalCost","indexesUsed","extractIndexes","release","planStr","includes","nestedLoops","match","indexes","indexMatches","matchAll","bitmapMatches","Set","getIndexSuggestions","tableName","statsQuery","stats","tableStats","dead_rows","row_count","deadRatio","table","columns","reason","toFixed","estimatedImprovement","indexQuery","unusedIndexes","idx","index_scans","index_name","columnStatsQuery","columnStats","col","n_distinct","null_frac","column_name","getDatabaseStats","tableCountQuery","indexCountQuery","totalSizeQuery","connectionCountQuery","cacheHitQuery","tables","size","connections","cache","Promise","all","tableCount","parseInt","count","indexCount","totalSize","pg_size_pretty","connectionCount","cacheHitRatio","parseFloat","ratio","vacuumAnalyze","clearSlowQueryLogs","getPerformanceSummary","totalSlowQueries","averageDuration","slowestQuery","totalDuration","reduce","sum","slowest","prev","current","configService","Logger","name","DEFAULT_OPTIMIZATION_CONFIG","slowQueryThreshold","get"],"mappings":"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"}