{"version":3,"sources":["../../../../src/enterprise/audit/services/worm-audit.service.ts"],"sourcesContent":["import { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, Between, MoreThan } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport * as crypto from 'crypto';\nimport { WormAuditLog } from '../entities/WormAuditLog.entity';\nimport { Organization } from '../../../database/entities/Organization.entity';\nimport {\n    AuditEntry,\n    AuditActionType,\n    WormAuditConfig,\n    DEFAULT_WORM_CONFIG,\n    ENTERPRISE_RETENTION_DAYS,\n    STANDARD_RETENTION_DAYS,\n} from '../interfaces/worm-audit.interface';\n\n/**\n * WORM Audit Service\n * Provides immutable, tamper-evident audit logging\n */\n@Injectable()\nexport class WormAuditService {\n    private readonly logger = new Logger(WormAuditService.name);\n    private readonly config: WormAuditConfig;\n    private chainHeads: Map<string, { hash: string; index: number }> = new Map();\n\n    constructor(\n        @InjectRepository(WormAuditLog)\n        private readonly auditRepository: Repository<WormAuditLog>,\n        @InjectRepository(Organization)\n        private readonly organizationRepository: Repository<Organization>,\n        private readonly configService: ConfigService,\n    ) {\n        this.config = {\n            ...DEFAULT_WORM_CONFIG,\n            retentionDays: this.configService.get('AUDIT_RETENTION_DAYS', DEFAULT_WORM_CONFIG.retentionDays),\n        };\n    }\n\n    /**\n     * Log an audit event\n     */\n    async log(entry: Partial<AuditEntry>): Promise<WormAuditLog> {\n        const tenantId = entry.tenantId;\n        if (!tenantId) {\n            throw new Error('Tenant ID is required for audit logging');\n        }\n\n        // Get chain head for tenant\n        const chainHead = await this.getChainHead(tenantId);\n\n        // Create audit log entry\n        const auditLog = this.auditRepository.create({\n            tenantId,\n            userId: entry.userId,\n            action: entry.action as any,\n            entityType: entry.entityType,\n            entityId: entry.entityId,\n            oldValues: entry.oldValues,\n            newValues: entry.newValues,\n            changedFields: entry.changedFields,\n            ipAddress: entry.ipAddress,\n            userAgent: entry.userAgent,\n            requestId: entry.requestId,\n            sessionId: entry.sessionId,\n            metadata: entry.metadata || {},\n            timestamp: entry.timestamp || new Date(),\n            previousHash: chainHead?.hash,\n            chainIndex: (chainHead?.index || 0) + 1,\n            hash: '', // Will be calculated\n        });\n\n        // Calculate integrity hash\n        auditLog.hash = this.calculateHash(auditLog);\n\n        const saved = await this.auditRepository.save(auditLog);\n\n        // Update chain head cache\n        this.chainHeads.set(tenantId, { hash: saved.hash, index: saved.chainIndex });\n\n        this.logger.debug(`Audit log created: ${saved.id} for tenant ${tenantId}`);\n\n        return saved;\n    }\n\n    /**\n     * Calculate integrity hash for audit entry\n     */\n    private calculateHash(log: WormAuditLog): string {\n        const data = JSON.stringify({\n            tenantId: log.tenantId,\n            userId: log.userId,\n            action: log.action,\n            entityType: log.entityType,\n            entityId: log.entityId,\n            oldValues: log.oldValues,\n            newValues: log.newValues,\n            timestamp: log.timestamp,\n            previousHash: log.previousHash,\n            chainIndex: log.chainIndex,\n        });\n\n        return crypto.createHash('sha256').update(data).digest('hex');\n    }\n\n    /**\n     * Get chain head for tenant\n     */\n    private async getChainHead(tenantId: string): Promise<{ hash: string; index: number } | null> {\n        // Check cache first\n        if (this.chainHeads.has(tenantId)) {\n            return this.chainHeads.get(tenantId) || null;\n        }\n\n        // Query database\n        const latest = await this.auditRepository.findOne({\n            where: { tenantId },\n            order: { chainIndex: 'DESC' },\n            select: ['hash', 'chainIndex'],\n        });\n\n        if (latest) {\n            this.chainHeads.set(tenantId, { hash: latest.hash, index: latest.chainIndex });\n            return { hash: latest.hash, index: latest.chainIndex };\n        }\n\n        return null;\n    }\n\n    /**\n     * Verify audit chain integrity\n     */\n    async verifyChainIntegrity(tenantId: string): Promise<{ valid: boolean; brokenAt?: number; error?: string }> {\n        const logs = await this.auditRepository.find({\n            where: { tenantId },\n            order: { chainIndex: 'ASC' },\n            select: ['id', 'hash', 'previousHash', 'chainIndex', 'tenantId', 'userId', 'action', 'entityType', 'entityId', 'oldValues', 'newValues', 'timestamp'],\n        });\n\n        let previousHash: string | null = null;\n\n        for (const log of logs) {\n            // Verify hash\n            const calculatedHash = this.calculateHash(log as any);\n            if (calculatedHash !== log.hash) {\n                return {\n                    valid: false,\n                    brokenAt: log.chainIndex,\n                    error: 'Hash mismatch detected',\n                };\n            }\n\n            // Verify chain\n            if (previousHash !== null && log.previousHash !== previousHash) {\n                return {\n                    valid: false,\n                    brokenAt: log.chainIndex,\n                    error: 'Chain link broken',\n                };\n            }\n\n            previousHash = log.hash;\n        }\n\n        return { valid: true };\n    }\n\n    /**\n     * Get audit logs with filters\n     */\n    async getLogs(\n        tenantId: string,\n        options: {\n            userId?: string;\n            action?: AuditActionType;\n            entityType?: string;\n            entityId?: string;\n            startDate?: Date;\n            endDate?: Date;\n            page?: number;\n            limit?: number;\n        } = {}\n    ): Promise<{ data: WormAuditLog[]; total: number }> {\n        const page = options.page || 1;\n        const limit = Math.min(options.limit || 100, 1000);\n        const skip = (page - 1) * limit;\n\n        const queryBuilder = this.auditRepository.createQueryBuilder('log')\n            .where('log.tenantId = :tenantId', { tenantId })\n            .orderBy('log.timestamp', 'DESC')\n            .skip(skip)\n            .take(limit);\n\n        if (options.userId) {\n            queryBuilder.andWhere('log.userId = :userId', { userId: options.userId });\n        }\n\n        if (options.action) {\n            queryBuilder.andWhere('log.action = :action', { action: options.action });\n        }\n\n        if (options.entityType) {\n            queryBuilder.andWhere('log.entityType = :entityType', { entityType: options.entityType });\n        }\n\n        if (options.entityId) {\n            queryBuilder.andWhere('log.entityId = :entityId', { entityId: options.entityId });\n        }\n\n        if (options.startDate) {\n            queryBuilder.andWhere('log.timestamp >= :startDate', { startDate: options.startDate });\n        }\n\n        if (options.endDate) {\n            queryBuilder.andWhere('log.timestamp <= :endDate', { endDate: options.endDate });\n        }\n\n        const [data, total] = await queryBuilder.getManyAndCount();\n\n        return { data, total };\n    }\n\n    /**\n     * Export audit logs (for compliance)\n     */\n    async exportLogs(\n        tenantId: string,\n        format: 'json' | 'csv' = 'json',\n        options: { startDate?: Date; endDate?: Date } = {}\n    ): Promise<string> {\n        const { data } = await this.getLogs(tenantId, {\n            startDate: options.startDate,\n            endDate: options.endDate,\n            limit: 10000,\n        });\n\n        if (format === 'json') {\n            return JSON.stringify(data, null, 2);\n        }\n\n        // CSV format\n        const headers = ['ID', 'Timestamp', 'User ID', 'Action', 'Entity Type', 'Entity ID', 'IP Address', 'Hash'];\n        const rows = data.map(log => [\n            log.id,\n            log.timestamp.toISOString(),\n            log.userId || '',\n            log.action,\n            log.entityType,\n            log.entityId || '',\n            log.ipAddress || '',\n            log.hash,\n        ]);\n\n        return [\n            headers.join(','),\n            ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\n        ].join('\\n');\n    }\n\n    /**\n     * Get retention period for tenant\n     */\n    async getRetentionPeriod(tenantId: string): Promise<number> {\n        const organization = await this.organizationRepository.findOne({\n            where: { id: tenantId },\n            select: ['subscriptionPlan', 'auditRetentionDays'],\n        });\n\n        if (organization?.auditRetentionDays) {\n            return organization.auditRetentionDays;\n        }\n\n        return STANDARD_RETENTION_DAYS;\n    }\n\n    /**\n     * Clean up old audit logs based on retention policy\n     */\n    async cleanupOldLogs(): Promise<{ tenantsProcessed: number; logsDeleted: number }> {\n        const tenants = await this.organizationRepository.find({\n            where: { status: 'active' },\n            select: ['id', 'auditRetentionDays'],\n        });\n\n        let totalDeleted = 0;\n\n        for (const tenant of tenants) {\n            const retentionDays = tenant.auditRetentionDays || STANDARD_RETENTION_DAYS;\n            const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);\n\n            const result = await this.auditRepository.delete({\n                tenantId: tenant.id,\n                timestamp: MoreThan(cutoffDate) as any,\n            });\n\n            totalDeleted += result.affected || 0;\n        }\n\n        return {\n            tenantsProcessed: tenants.length,\n            logsDeleted: totalDeleted,\n        };\n    }\n\n    /**\n     * Log security event\n     */\n    async logSecurityEvent(\n        tenantId: string,\n        event: {\n            userId?: string;\n            action: AuditActionType;\n            details?: Record<string, any>;\n            ipAddress?: string;\n            userAgent?: string;\n            requestId?: string;\n        }\n    ): Promise<WormAuditLog> {\n        return this.log({\n            tenantId,\n            userId: event.userId,\n            action: event.action,\n            entityType: 'security',\n            metadata: event.details,\n            ipAddress: event.ipAddress,\n            userAgent: event.userAgent,\n            requestId: event.requestId,\n        });\n    }\n}\n"],"names":["WormAuditService","log","entry","tenantId","Error","chainHead","getChainHead","auditLog","auditRepository","create","userId","action","entityType","entityId","oldValues","newValues","changedFields","ipAddress","userAgent","requestId","sessionId","metadata","timestamp","Date","previousHash","hash","chainIndex","index","calculateHash","saved","save","chainHeads","set","logger","debug","id","data","JSON","stringify","crypto","createHash","update","digest","has","get","latest","findOne","where","order","select","verifyChainIntegrity","logs","find","calculatedHash","valid","brokenAt","error","getLogs","options","page","limit","Math","min","skip","queryBuilder","createQueryBuilder","orderBy","take","andWhere","startDate","endDate","total","getManyAndCount","exportLogs","format","headers","rows","map","toISOString","join","row","cell","getRetentionPeriod","organization","organizationRepository","auditRetentionDays","STANDARD_RETENTION_DAYS","cleanupOldLogs","tenants","status","totalDeleted","tenant","retentionDays","cutoffDate","now","result","delete","MoreThan","affected","tenantsProcessed","length","logsDeleted","logSecurityEvent","event","details","configService","Logger","name","Map","config","DEFAULT_WORM_CONFIG"],"mappings":"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"}