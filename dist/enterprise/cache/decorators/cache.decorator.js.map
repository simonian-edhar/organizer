{"version":3,"sources":["../../../../src/enterprise/cache/decorators/cache.decorator.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\nimport { RedisCacheService } from '../services/redis-cache.service';\n\n/**\n * Cache Decorator\n * Method-level caching with automatic key generation\n */\nexport function Cached(ttl: number = 3600, tags: string[] = []) {\n    return function (\n        target: any,\n        propertyKey: string,\n        descriptor: PropertyDescriptor\n    ) {\n        const originalMethod = descriptor.value;\n\n        descriptor.value = async function (...args: any[]) {\n            const cacheService = this.cacheService as RedisCacheService;\n\n            if (!cacheService) {\n                return originalMethod.apply(this, args);\n            }\n\n            // Build cache key from method name and arguments\n            const cacheKey = `${propertyKey}:${JSON.stringify(args)}`;\n\n            // Try cache first\n            const cached = await cacheService.get(cacheKey);\n            if (cached !== null) {\n                return cached;\n            }\n\n            // Execute method and cache result\n            const result = await originalMethod.apply(this, args);\n            await cacheService.set(cacheKey, result, ttl, tags);\n\n            return result;\n        };\n\n        return descriptor;\n    };\n}\n\n/**\n * Cache Evict Decorator\n * Evicts cache entries after method execution\n */\nexport function CacheEvict(...tags: string[]) {\n    return function (\n        target: any,\n        propertyKey: string,\n        descriptor: PropertyDescriptor\n    ) {\n        const originalMethod = descriptor.value;\n\n        descriptor.value = async function (...args: any[]) {\n            const cacheService = this.cacheService as RedisCacheService;\n\n            // Execute method first\n            const result = await originalMethod.apply(this, args);\n\n            // Evict cache by tags\n            if (cacheService && tags.length > 0) {\n                for (const tag of tags) {\n                    // Replace placeholders with actual values from first arg (usually tenant-based)\n                    const actualTag = tag.replace('{0}', args[0] || '');\n                    await cacheService.invalidateByTag(actualTag);\n                }\n            }\n\n            return result;\n        };\n\n        return descriptor;\n    };\n}\n"],"names":["CacheEvict","Cached","ttl","tags","target","propertyKey","descriptor","originalMethod","value","args","cacheService","apply","cacheKey","JSON","stringify","cached","get","result","set","length","tag","actualTag","replace","invalidateByTag"],"mappings":";;;;;;;;;;;QA8CgBA;eAAAA;;QAvCAC;eAAAA;;;AAAT,SAASA,OAAOC,MAAc,IAAI,EAAEC,OAAiB,EAAE;IAC1D,OAAO,SACHC,MAAW,EACXC,WAAmB,EACnBC,UAA8B;QAE9B,MAAMC,iBAAiBD,WAAWE,KAAK;QAEvCF,WAAWE,KAAK,GAAG,eAAgB,GAAGC,IAAW;YAC7C,MAAMC,eAAe,IAAI,CAACA,YAAY;YAEtC,IAAI,CAACA,cAAc;gBACf,OAAOH,eAAeI,KAAK,CAAC,IAAI,EAAEF;YACtC;YAEA,iDAAiD;YACjD,MAAMG,WAAW,GAAGP,YAAY,CAAC,EAAEQ,KAAKC,SAAS,CAACL,OAAO;YAEzD,kBAAkB;YAClB,MAAMM,SAAS,MAAML,aAAaM,GAAG,CAACJ;YACtC,IAAIG,WAAW,MAAM;gBACjB,OAAOA;YACX;YAEA,kCAAkC;YAClC,MAAME,SAAS,MAAMV,eAAeI,KAAK,CAAC,IAAI,EAAEF;YAChD,MAAMC,aAAaQ,GAAG,CAACN,UAAUK,QAAQf,KAAKC;YAE9C,OAAOc;QACX;QAEA,OAAOX;IACX;AACJ;AAMO,SAASN,WAAW,GAAGG,IAAc;IACxC,OAAO,SACHC,MAAW,EACXC,WAAmB,EACnBC,UAA8B;QAE9B,MAAMC,iBAAiBD,WAAWE,KAAK;QAEvCF,WAAWE,KAAK,GAAG,eAAgB,GAAGC,IAAW;YAC7C,MAAMC,eAAe,IAAI,CAACA,YAAY;YAEtC,uBAAuB;YACvB,MAAMO,SAAS,MAAMV,eAAeI,KAAK,CAAC,IAAI,EAAEF;YAEhD,sBAAsB;YACtB,IAAIC,gBAAgBP,KAAKgB,MAAM,GAAG,GAAG;gBACjC,KAAK,MAAMC,OAAOjB,KAAM;oBACpB,gFAAgF;oBAChF,MAAMkB,YAAYD,IAAIE,OAAO,CAAC,OAAOb,IAAI,CAAC,EAAE,IAAI;oBAChD,MAAMC,aAAaa,eAAe,CAACF;gBACvC;YACJ;YAEA,OAAOJ;QACX;QAEA,OAAOX;IACX;AACJ"}