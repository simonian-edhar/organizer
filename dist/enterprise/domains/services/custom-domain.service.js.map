{"version":3,"sources":["../../../../src/enterprise/domains/services/custom-domain.service.ts"],"sourcesContent":["import { Injectable, Logger, NotFoundException, BadRequestException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { ConfigService } from '@nestjs/config';\nimport * as dns from 'dns';\nimport { promisify } from 'util';\nimport { CustomDomain } from '../entities/CustomDomain.entity';\nimport { Organization } from '../../../database/entities/Organization.entity';\nimport { SubscriptionPlan } from '../../../database/entities/enums/subscription.enum';\nimport {\n    CustomDomainConfig,\n    DnsRecord,\n    DomainVerificationResult,\n    DNS_VERIFICATION_PREFIX,\n} from '../interfaces/custom-domain.interface';\n\nconst resolveTxt = promisify(dns.resolveTxt);\nconst resolveCname = promisify(dns.resolveCname);\n\n/**\n * Custom Domain Service\n * Manages custom domains for Enterprise tenants\n */\n@Injectable()\nexport class CustomDomainService {\n    private readonly logger = new Logger(CustomDomainService.name);\n    private readonly baseDomain: string;\n\n    constructor(\n        @InjectRepository(CustomDomain)\n        private readonly domainRepository: Repository<CustomDomain>,\n        @InjectRepository(Organization)\n        private readonly organizationRepository: Repository<Organization>,\n        private readonly configService: ConfigService,\n    ) {\n        this.baseDomain = this.configService.get('BASE_DOMAIN', 'law-organizer.ua');\n    }\n\n    /**\n     * Add custom domain for tenant\n     */\n    async addDomain(tenantId: string, domain: string): Promise<CustomDomain> {\n        // Verify tenant has Enterprise plan\n        await this.verifyEnterprisePlan(tenantId);\n\n        // Check domain doesn't already exist\n        const existing = await this.domainRepository.findOne({\n            where: { domain: domain.toLowerCase() },\n        });\n\n        if (existing) {\n            throw new BadRequestException('Domain already registered');\n        }\n\n        // Generate verification token\n        const verificationToken = this.generateVerificationToken();\n\n        // Create DNS records for verification\n        const dnsRecords: DnsRecord[] = [\n            {\n                type: 'TXT',\n                name: `${DNS_VERIFICATION_PREFIX}.${domain}`,\n                value: verificationToken,\n                verified: false,\n            },\n            {\n                type: 'CNAME',\n                name: domain,\n                value: `tenant.${this.baseDomain}`,\n                verified: false,\n            },\n        ];\n\n        const customDomain = this.domainRepository.create({\n            tenantId,\n            domain: domain.toLowerCase(),\n            isVerified: false,\n            isPrimary: false,\n            dnsRecords,\n            verificationToken,\n        });\n\n        return this.domainRepository.save(customDomain);\n    }\n\n    /**\n     * Verify domain ownership via DNS\n     */\n    async verifyDomain(tenantId: string, domainId: string): Promise<DomainVerificationResult> {\n        const customDomain = await this.domainRepository.findOne({\n            where: { id: domainId, tenantId },\n        });\n\n        if (!customDomain) {\n            throw new NotFoundException('Domain not found');\n        }\n\n        const errors: string[] = [];\n        const dnsRecords = [...customDomain.dnsRecords];\n\n        // Verify TXT record for ownership\n        try {\n            const txtRecords = await resolveTxt(`${DNS_VERIFICATION_PREFIX}.${customDomain.domain}`);\n            const flattened = txtRecords.flat();\n\n            if (flattened.includes(customDomain.verificationToken)) {\n                const txtIndex = dnsRecords.findIndex(r => r.type === 'TXT');\n                if (txtIndex >= 0) {\n                    dnsRecords[txtIndex].verified = true;\n                }\n            } else {\n                errors.push('TXT verification record not found or incorrect');\n            }\n        } catch (error) {\n            errors.push('Unable to verify TXT record');\n        }\n\n        // Verify CNAME record\n        try {\n            const cnameRecords = await resolveCname(customDomain.domain);\n            const expectedCname = `tenant.${this.baseDomain}`;\n\n            if (cnameRecords.some(r => r.includes(this.baseDomain))) {\n                const cnameIndex = dnsRecords.findIndex(r => r.type === 'CNAME');\n                if (cnameIndex >= 0) {\n                    dnsRecords[cnameIndex].verified = true;\n                }\n            } else {\n                errors.push(`CNAME record should point to ${expectedCname}`);\n            }\n        } catch (error) {\n            errors.push('Unable to verify CNAME record');\n        }\n\n        // Update domain status\n        const allVerified = dnsRecords.every(r => r.verified);\n\n        customDomain.dnsRecords = dnsRecords;\n        customDomain.isVerified = allVerified;\n        if (allVerified) {\n            customDomain.verifiedAt = new Date();\n        }\n\n        await this.domainRepository.save(customDomain);\n\n        // If verified, update organization's custom domain\n        if (allVerified) {\n            await this.organizationRepository.update(\n                { id: tenantId },\n                { customDomain: customDomain.domain }\n            );\n\n            this.logger.log(`Domain verified: ${customDomain.domain} for tenant ${tenantId}`);\n        }\n\n        return {\n            success: allVerified,\n            domain: customDomain.domain,\n            dnsRecords,\n            errors: errors.length > 0 ? errors : undefined,\n        };\n    }\n\n    /**\n     * Set domain as primary\n     */\n    async setPrimaryDomain(tenantId: string, domainId: string): Promise<CustomDomain> {\n        const customDomain = await this.domainRepository.findOne({\n            where: { id: domainId, tenantId, isVerified: true },\n        });\n\n        if (!customDomain) {\n            throw new NotFoundException('Verified domain not found');\n        }\n\n        // Unset current primary\n        await this.domainRepository.update(\n            { tenantId, isPrimary: true },\n            { isPrimary: false }\n        );\n\n        // Set new primary\n        customDomain.isPrimary = true;\n        await this.domainRepository.save(customDomain);\n\n        return customDomain;\n    }\n\n    /**\n     * Remove custom domain\n     */\n    async removeDomain(tenantId: string, domainId: string): Promise<void> {\n        const customDomain = await this.domainRepository.findOne({\n            where: { id: domainId, tenantId },\n        });\n\n        if (!customDomain) {\n            throw new NotFoundException('Domain not found');\n        }\n\n        await this.domainRepository.remove(customDomain);\n\n        // Update organization if primary domain was removed\n        if (customDomain.isPrimary) {\n            await this.organizationRepository.update(\n                { id: tenantId },\n                { customDomain: null }\n            );\n        }\n    }\n\n    /**\n     * Get all domains for tenant\n     */\n    async getDomains(tenantId: string): Promise<CustomDomain[]> {\n        return this.domainRepository.find({\n            where: { tenantId },\n            order: { isPrimary: 'DESC', createdAt: 'DESC' },\n        });\n    }\n\n    /**\n     * Get domain by ID\n     */\n    async getDomain(tenantId: string, domainId: string): Promise<CustomDomain> {\n        const domain = await this.domainRepository.findOne({\n            where: { id: domainId, tenantId },\n        });\n\n        if (!domain) {\n            throw new NotFoundException('Domain not found');\n        }\n\n        return domain;\n    }\n\n    /**\n     * Generate SSL certificate for domain (using Let's Encrypt or similar)\n     */\n    async generateSslCertificate(tenantId: string, domainId: string): Promise<CustomDomain> {\n        const customDomain = await this.domainRepository.findOne({\n            where: { id: domainId, tenantId, isVerified: true },\n        });\n\n        if (!customDomain) {\n            throw new NotFoundException('Verified domain not found');\n        }\n\n        // In production, integrate with Let's Encrypt via ACME\n        // This is a placeholder for the SSL generation logic\n        this.logger.log(`SSL certificate generation initiated for ${customDomain.domain}`);\n\n        // Mark SSL as enabled (in production, actual cert would be stored)\n        customDomain.sslEnabled = true;\n        customDomain.sslExpiresAt = new Date(Date.now() + 90 * 24 * 60 * 60 * 1000); // 90 days\n\n        return this.domainRepository.save(customDomain);\n    }\n\n    /**\n     * Get tenant by domain (for request routing)\n     */\n    async getTenantByDomain(domain: string): Promise<Organization | null> {\n        const customDomain = await this.domainRepository.findOne({\n            where: { domain: domain.toLowerCase(), isVerified: true },\n            relations: ['organization'],\n        });\n\n        return customDomain?.organization || null;\n    }\n\n    /**\n     * Verify tenant has Enterprise plan\n     */\n    private async verifyEnterprisePlan(tenantId: string): Promise<void> {\n        const organization = await this.organizationRepository.findOne({\n            where: { id: tenantId },\n            select: ['subscriptionPlan'],\n        });\n\n        if (!organization || organization.subscriptionPlan !== SubscriptionPlan.ENTERPRISE) {\n            throw new BadRequestException('Custom domains require Enterprise subscription');\n        }\n    }\n\n    /**\n     * Generate verification token\n     */\n    private generateVerificationToken(): string {\n        const crypto = require('crypto');\n        return `law-organizer-verify=${crypto.randomBytes(32).toString('hex')}`;\n    }\n}\n"],"names":["CustomDomainService","resolveTxt","promisify","dns","resolveCname","addDomain","tenantId","domain","verifyEnterprisePlan","existing","domainRepository","findOne","where","toLowerCase","BadRequestException","verificationToken","generateVerificationToken","dnsRecords","type","name","DNS_VERIFICATION_PREFIX","value","verified","baseDomain","customDomain","create","isVerified","isPrimary","save","verifyDomain","domainId","id","NotFoundException","errors","txtRecords","flattened","flat","includes","txtIndex","findIndex","r","push","error","cnameRecords","expectedCname","some","cnameIndex","allVerified","every","verifiedAt","Date","organizationRepository","update","logger","log","success","length","undefined","setPrimaryDomain","removeDomain","remove","getDomains","find","order","createdAt","getDomain","generateSslCertificate","sslEnabled","sslExpiresAt","now","getTenantByDomain","relations","organization","select","subscriptionPlan","SubscriptionPlan","ENTERPRISE","crypto","require","randomBytes","toString","configService","Logger","get"],"mappings":"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"}