{"version":3,"sources":["../../../src/cases/services/case.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository, Between } from 'typeorm';\nimport { Case } from '../../database/entities/Case.entity';\nimport { CreateCaseDto, UpdateCaseDto, CaseFiltersDto, AddTimelineEventDto } from '../dto/case.dto';\nimport { detectSqlInjection } from '../../common/utils/validation.util';\n\n/**\n * Case Service\n */\n@Injectable()\nexport class CaseService {\n    constructor(\n        @InjectRepository(Case)\n        private readonly caseRepository: Repository<Case>,\n    ) {}\n\n    /**\n     * Get all cases with filters\n     */\n    async findAll(\n        tenantId: string,\n        filters: CaseFiltersDto = {}\n    ): Promise<{ data: Case[]; total: number; page: number; limit: number }> {\n        const query = this.caseRepository\n            .createQueryBuilder('case')\n            .where('case.tenantId = :tenantId AND case.deletedAt IS NULL', { tenantId });\n\n        // Filter by client\n        if (filters.clientId) {\n            query.andWhere('case.clientId = :clientId', { clientId: filters.clientId });\n        }\n\n        // Filter by assigned lawyer\n        if (filters.assignedLawyerId) {\n            query.andWhere('case.assignedLawyerId = :assignedLawyerId', {\n                assignedLawyerId: filters.assignedLawyerId,\n            });\n        }\n\n        // Filter by case type\n        if (filters.caseType) {\n            query.andWhere('case.caseType = :caseType', { caseType: filters.caseType });\n        }\n\n        // Filter by priority\n        if (filters.priority) {\n            query.andWhere('case.priority = :priority', { priority: filters.priority });\n        }\n\n        // Filter by status\n        if (filters.status) {\n            query.andWhere('case.status = :status', { status: filters.status });\n        }\n\n        // Filter by start date range\n        if (filters.startDateFrom && filters.startDateTo) {\n            query.andWhere('case.startDate BETWEEN :startDateFrom AND :startDateTo', {\n                startDateFrom: new Date(filters.startDateFrom),\n                startDateTo: new Date(filters.startDateTo),\n            });\n        } else if (filters.startDateFrom) {\n            query.andWhere('case.startDate >= :startDateFrom', {\n                startDateFrom: new Date(filters.startDateFrom),\n            });\n        } else if (filters.startDateTo) {\n            query.andWhere('case.startDate <= :startDateTo', {\n                startDateTo: new Date(filters.startDateTo),\n            });\n        }\n\n        // Filter by deadline range\n        if (filters.deadlineFrom && filters.deadlineTo) {\n            query.andWhere('case.deadlineDate BETWEEN :deadlineFrom AND :deadlineTo', {\n                deadlineFrom: new Date(filters.deadlineFrom),\n                deadlineTo: new Date(filters.deadlineTo),\n            });\n        } else if (filters.deadlineFrom) {\n            query.andWhere('case.deadlineDate >= :deadlineFrom', {\n                deadlineFrom: new Date(filters.deadlineFrom),\n            });\n        } else if (filters.deadlineTo) {\n            query.andWhere('case.deadlineDate <= :deadlineTo', {\n                deadlineTo: new Date(filters.deadlineTo),\n            });\n        }\n\n        // Search\n        if (filters.search) {\n            if (detectSqlInjection(filters.search)) {\n                throw new ForbiddenException('Invalid search query');\n            }\n\n            query.andWhere(\n                '(case.caseNumber ILIKE :search OR ' +\n                'case.title ILIKE :search OR ' +\n                'case.description ILIKE :search OR ' +\n                'case.courtName ILIKE :search OR ' +\n                'case.judgeName ILIKE :search)',\n                { search: `%${filters.search}%` }\n            );\n        }\n\n        // Sorting\n        const sortBy = filters.sortBy || 'createdAt';\n        const sortOrder = filters.sortOrder || 'DESC';\n        query.orderBy(`case.${sortBy}`, sortOrder);\n\n        // Pagination\n        const page = filters.page || 1;\n        const limit = filters.limit || 20;\n        const skip = (page - 1) * limit;\n\n        query.skip(skip).take(limit);\n\n        // Include relations\n        query.leftJoinAndSelect('case.client', 'client');\n        query.leftJoinAndSelect('case.assignedLawyer', 'assignedLawyer');\n\n        const [data, total] = await query.getManyAndCount();\n\n        return {\n            data,\n            total,\n            page,\n            limit,\n        };\n    }\n\n    /**\n     * Get case by ID\n     */\n    async findById(tenantId: string, id: string): Promise<Case> {\n        const caseEntity = await this.caseRepository.findOne({\n            where: {\n                id,\n                tenantId,\n                deletedAt: null,\n            },\n            relations: ['client', 'assignedLawyer', 'documents', 'events'],\n        });\n\n        if (!caseEntity) {\n            throw new NotFoundException('Справу не знайдено');\n        }\n\n        return caseEntity;\n    }\n\n    /**\n     * Get case timeline (events and documents history)\n     */\n    async getTimeline(tenantId: string, id: string): Promise<any> {\n        const caseEntity = await this.findById(tenantId, id);\n\n        // Combine events and documents into timeline\n        const events = caseEntity.events || [];\n        const documents = caseEntity.documents || [];\n\n        const timeline = [\n            ...events.map(e => ({\n                type: 'event',\n                date: e.eventDate,\n                data: e,\n            })),\n            ...documents.map(d => ({\n                type: 'document',\n                date: d.uploadedAt,\n                data: d,\n            })),\n        ].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n\n        return timeline;\n    }\n\n    /**\n     * Create new case\n     */\n    async create(tenantId: string, userId: string, dto: CreateCaseDto): Promise<Case> {\n        const caseEntity = this.caseRepository.create({\n            tenantId,\n            ...dto,\n            status: 'draft',\n            startDate: dto.startDate ? new Date(dto.startDate) : new Date(),\n            endDate: dto.endDate ? new Date(dto.endDate) : null,\n            deadlineDate: dto.deadlineDate ? new Date(dto.deadlineDate) : null,\n            estimatedAmount: dto.estimatedAmount || 0,\n            paidAmount: 0,\n            metadata: dto.metadata || {},\n            createdBy: userId,\n            updatedBy: userId,\n        });\n\n        return this.caseRepository.save(caseEntity);\n    }\n\n    /**\n     * Update case\n     */\n    async update(\n        tenantId: string,\n        id: string,\n        userId: string,\n        dto: UpdateCaseDto\n    ): Promise<Case> {\n        const caseEntity = await this.findById(tenantId, id);\n\n        const updateData: Partial<Case> = {\n            ...dto,\n            updatedBy: userId,\n        };\n\n        // Handle date fields\n        if (dto.startDate) {\n            updateData.startDate = new Date(dto.startDate);\n        }\n        if (dto.endDate) {\n            updateData.endDate = new Date(dto.endDate);\n        }\n        if (dto.nextHearingDate) {\n            updateData.nextHearingDate = new Date(dto.nextHearingDate);\n        }\n        if (dto.deadlineDate) {\n            updateData.deadlineDate = new Date(dto.deadlineDate);\n        }\n\n        Object.assign(caseEntity, updateData);\n\n        return this.caseRepository.save(caseEntity);\n    }\n\n    /**\n     * Delete case (soft delete)\n     */\n    async delete(tenantId: string, id: string, userId: string): Promise<void> {\n        const caseEntity = await this.findById(tenantId, id);\n\n        await this.caseRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: new Date(),\n                updatedBy: userId,\n            }\n        );\n    }\n\n    /**\n     * Restore deleted case\n     */\n    async restore(tenantId: string, id: string, userId: string): Promise<Case> {\n        await this.caseRepository.update(\n            { id, tenantId },\n            {\n                deletedAt: null,\n                updatedBy: userId,\n            }\n        );\n\n        return this.findById(tenantId, id);\n    }\n\n    /**\n     * Change case status\n     */\n    async changeStatus(\n        tenantId: string,\n        id: string,\n        userId: string,\n        status: 'draft' | 'active' | 'on_hold' | 'closed' | 'archived'\n    ): Promise<Case> {\n        const caseEntity = await this.findById(tenantId, id);\n\n        caseEntity.status = status;\n        caseEntity.updatedBy = userId;\n\n        if (status === 'closed') {\n            caseEntity.endDate = new Date();\n        }\n\n        return this.caseRepository.save(caseEntity);\n    }\n\n    /**\n     * Get upcoming deadlines\n     */\n    async getUpcomingDeadlines(tenantId: string, days: number = 30): Promise<Case[]> {\n        const now = new Date();\n        const futureDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);\n\n        return this.caseRepository.find({\n            where: {\n                tenantId,\n                deadlineDate: Between(now, futureDate),\n                status: 'active',\n                deletedAt: null,\n            },\n            order: {\n                deadlineDate: 'ASC',\n            },\n            relations: ['client', 'assignedLawyer'],\n        });\n    }\n\n    /**\n     * Get cases statistics\n     */\n    async getStatistics(tenantId: string): Promise<{\n        total: number;\n        byStatus: Record<string, number>;\n        byType: Record<string, number>;\n        byPriority: Record<string, number>;\n        activeCases: number;\n        upcomingDeadlines: number;\n    }> {\n        const totalQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('COUNT(*)', 'count')\n            .where('case.tenantId = :tenantId AND case.deletedAt IS NULL', { tenantId });\n\n        const byStatusQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('case.status', 'status')\n            .addSelect('COUNT(*)', 'count')\n            .where('case.tenantId = :tenantId AND case.deletedAt IS NULL', { tenantId })\n            .groupBy('case.status');\n\n        const byTypeQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('case.caseType', 'caseType')\n            .addSelect('COUNT(*)', 'count')\n            .where('case.tenantId = :tenantId AND case.deletedAt IS NULL', { tenantId })\n            .groupBy('case.caseType');\n\n        const byPriorityQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('case.priority', 'priority')\n            .addSelect('COUNT(*)', 'count')\n            .where('case.tenantId = :tenantId AND case.deletedAt IS NULL', { tenantId })\n            .groupBy('case.priority');\n\n        const activeCasesQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('COUNT(*)', 'count')\n            .where('case.tenantId = :tenantId AND case.status = :status AND case.deletedAt IS NULL', {\n                tenantId,\n                status: 'active',\n            });\n\n        const now = new Date();\n        const futureDate = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);\n        const upcomingDeadlinesQuery = this.caseRepository\n            .createQueryBuilder('case')\n            .select('COUNT(*)', 'count')\n            .where(\n                'case.tenantId = :tenantId AND case.deadlineDate BETWEEN :now AND :future AND case.deletedAt IS NULL',\n                { tenantId, now, future }\n            );\n\n        const [totalResult, byStatusResult, byTypeResult, byPriorityResult, activeCasesResult, upcomingDeadlinesResult] =\n            await Promise.all([\n                totalQuery.getRawOne(),\n                byStatusQuery.getRawMany(),\n                byTypeQuery.getRawMany(),\n                byPriorityQuery.getRawMany(),\n                activeCasesQuery.getRawOne(),\n                upcomingDeadlinesQuery.getRawOne(),\n            ]);\n\n        return {\n            total: parseInt(totalResult?.count || '0'),\n            byStatus: byStatusResult.reduce((acc, row) => {\n                acc[row.status] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            byType: byTypeResult.reduce((acc, row) => {\n                acc[row.caseType] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            byPriority: byPriorityResult.reduce((acc, row) => {\n                acc[row.priority] = parseInt(row.count);\n                return acc;\n            }, {} as Record<string, number>),\n            activeCases: parseInt(activeCasesResult?.count || '0'),\n            upcomingDeadlines: parseInt(upcomingDeadlinesResult?.count || '0'),\n        };\n    }\n}\n"],"names":["CaseService","findAll","tenantId","filters","query","caseRepository","createQueryBuilder","where","clientId","andWhere","assignedLawyerId","caseType","priority","status","startDateFrom","startDateTo","Date","deadlineFrom","deadlineTo","search","detectSqlInjection","ForbiddenException","sortBy","sortOrder","orderBy","page","limit","skip","take","leftJoinAndSelect","data","total","getManyAndCount","findById","id","caseEntity","findOne","deletedAt","relations","NotFoundException","getTimeline","events","documents","timeline","map","e","type","date","eventDate","d","uploadedAt","sort","a","b","getTime","create","userId","dto","startDate","endDate","deadlineDate","estimatedAmount","paidAmount","metadata","createdBy","updatedBy","save","update","updateData","nextHearingDate","Object","assign","delete","restore","changeStatus","getUpcomingDeadlines","days","now","futureDate","find","Between","order","getStatistics","totalQuery","select","byStatusQuery","addSelect","groupBy","byTypeQuery","byPriorityQuery","activeCasesQuery","upcomingDeadlinesQuery","future","totalResult","byStatusResult","byTypeResult","byPriorityResult","activeCasesResult","upcomingDeadlinesResult","Promise","all","getRawOne","getRawMany","parseInt","count","byStatus","reduce","acc","row","byType","byPriority","activeCases","upcomingDeadlines"],"mappings":"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"}